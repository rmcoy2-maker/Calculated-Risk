from __future__ import annotations
# === AppImportGuard (robust) ===
try:
    from app.lib.auth import login, show_logout
except ModuleNotFoundError:
    import sys
    from pathlib import Path
    here = Path(__file__).resolve()
    su = None
    for p in [here] + list(here.parents):
        if (p / "serving_ui" / "app" / "__init__.py").exists():
            su = (p / "serving_ui")
            break
        if p.name == "serving_ui" and (p / "app" / "__init__.py").exists():
            su = p
            break
        if p.name == "app" and p.parent.name == "serving_ui" and (p / "__init__.py").exists():
            su = p.parent
            break
    if su and (s := str(su)) not in sys.path:
        sys.path.insert(0, s)
    from app.lib.auth import login, show_logout  # type: ignore
# === /AppImportGuard ===
import streamlit as st
from app.lib.auth import login, show_logout
# === Auth (auto-injected) ===
import streamlit as st  # ensured
from app.lib.auth import login, show_logout

auth = login(required=False)   # or required=True for protected pages
if not auth.authenticated:
    st.info("You are in read-only mode.")
show_logout()  # sidebar logout
# === /Auth (auto-injected) ===
import streamlit as st
try:
except Exception:
    pass
st.markdown("""
<style>
  .block-container { max-width: none !important; padding-left: 1rem; padding-right: 1rem; }
  [data-testid="stHeader"] { z-index: 9990; }
</style>
""", unsafe_allow_html=True)
# -*- coding: utf-8 -*-
# app/pages/03_Backtest.py â€” v4: season fallback + never-drop filters
# --- auto-added: newest-first patch ---
try:
    import streamlit as st  # ensure alias available
except Exception:
    import streamlit as st
from app.utils.newest_first_patch import apply_newest_first_patch as __nfp_apply
__nfp_apply(st)
# --- end auto-added ---

import datetime as dt
from pathlib import Path
from typing import Dict, List, Tuple

import numpy as np
import pandas as pd
import streamlit as st

# ---------------- Paths ----------------
_REPO_ROOT = Path(__file__).resolve().parents[3]  # C:\Projects\edge-finder
EXPORTS = _REPO_ROOT / "exports"
EXPORTS.mkdir(parents=True, exist_ok=True)

# ---------------- Helpers ----------------
def _read_csv_safe(path: Path) -> pd.DataFrame:
    try:
        if not path.exists() or path.stat().st_size == 0:
            return pd.DataFrame()
        return pd.read_csv(path)
    except Exception:
        return pd.DataFrame()

def american_to_decimal(odds: float) -> float:
    o = float(odds)
    return 1 + (o/100.0 if o > 0 else 100.0/abs(o))

def implied_prob_from_american(am: float) -> float:
    am = float(am)
    return 100.0 / (am + 100.0) if am >= 0 else abs(am) / (abs(am) + 100.0)

def kelly_fraction(p: float, american_odds: float, fraction: float = 0.5) -> float:
    try:
        p = float(p)
        b = american_to_decimal(float(american_odds)) - 1.0
        q = 1.0 - p
        if b <= 0 or not (0.0 < p < 1.0):
            return 0.0
        f = (b * p - q) / b
        return max(0.0, min(1.0, f * float(fraction)))
    except Exception:
        return 0.0

def settle_row(row) -> tuple[float, bool]:
    try:
        stake = float((row.get("stake", 0) if hasattr(row, "get") else row["stake"]) or 0)
        odds  = float((row.get("odds", 0)  if hasattr(row, "get") else row["odds"])  or 0)
        res   = (row.get("result", "") if hasattr(row, "get") else row.get("result", ""))
        res   = str(res or "").lower()
        dec   = american_to_decimal(odds)
        if res in ("win","won","w"):   return stake * (dec - 1.0), True
        if res in ("lose","lost","l"): return -stake, True
        if res in ("push","void","cancel","canceled","cancelled"): return 0.0, True
        return 0.0, False
    except Exception:
        return 0.0, False

def normalize_bets(df: pd.DataFrame, source_tag: str) -> pd.DataFrame:
    if df is None or df.empty:
        return pd.DataFrame()
    df = df.copy()
    df.columns = [c.strip().lower() for c in df.columns]
    keep = ["ts","sport","league","game_id","season","week","market","ref","side","line","odds","p_win","ev","result","stake","placed_at"]
    for c in keep:
        if c not in df.columns:
            df[c] = None
    ts = pd.to_datetime(df["placed_at"], errors="coerce")
    ts = ts.where(ts.notna(), pd.to_datetime(df["ts"], errors="coerce"))
    df["placed_at"] = ts
    df["odds"]  = pd.to_numeric(df["odds"], errors="coerce")
    df["stake"] = pd.to_numeric(df["stake"], errors="coerce").fillna(0.0)
    df["p_win"] = pd.to_numeric(df["p_win"], errors="coerce")
    df["src"]   = source_tag
    return df

_MARKET_GROUPS = {
    "Moneyline":   ["ml","moneyline","money line","money-line"],
    "Spread":      ["spread","ats","handicap","point spread"],
    "Total (O/U)": ["total","totals","o/u","over/under","ou"],
    "Props":       ["prop","props","player","passing","rushing","receiving","td","interception","tackles","sacks"],
    "Parlay":      ["parlay"],
}
def classify_market(val: str) -> str:
    t = str(val or "").lower()
    for group, kws in _MARKET_GROUPS.items():
        if any(kw in t for kw in kws):
            return group
    if t == "total":
        return "Total (O/U)"
    return "Other"

def bankroll_curve(df: pd.DataFrame, bankroll_start: float = 100.0) -> pd.DataFrame:
    if df is None or df.empty:
        return pd.DataFrame(columns=["placed_at","bankroll","running_max","drawdown"])
    x = df.sort_values("placed_at").copy()
    x["pnl_realized"] = pd.to_numeric(x.get("pnl", 0), errors="coerce").fillna(0.0)
    x["cum_pnl"] = x["pnl_realized"].cumsum()
    x["bankroll"] = bankroll_start + x["cum_pnl"]
    x["running_max"] = x["bankroll"].cummax()
    x["drawdown"] = x["bankroll"] - x["running_max"]
    return x[["placed_at","bankroll","running_max","drawdown"]]

def summarize(df: pd.DataFrame, curve: pd.DataFrame) -> pd.DataFrame:
    if "result" not in df.columns:
        df = df.copy(); df["result"] = np.nan
    total_staked = float(pd.to_numeric(df.get("stake", pd.Series(dtype=float)), errors="coerce").fillna(0).sum())
    realized_mask = df.get("result", pd.Series(dtype=str)).astype(str).str.lower().isin(
        ["win","won","w","lose","lost","l","push","void","cancel","canceled","cancelled"]
    )
    realized = df[realized_mask].copy()
    wins   = realized["result"].astype(str).str.lower().isin(["win","won","w"]).sum()
    losses = realized["result"].astype(str).str.lower().isin(["lose","lost","l"]).sum()
    pushes = realized["result"].astype(str).str.lower().isin(["push","void","cancel","canceled","cancelled"]).sum()
    settled = len(realized)
    realized_pnl = float(pd.to_numeric(realized.get("pnl", 0), errors="coerce").fillna(0).sum())
    if realized_pnl == 0 and settled:
        total = 0.0
        for _, r in realized.iterrows():
            pnl, _ = settle_row(r if r.get("stake") not in (None, 0) else {"stake": r.get("stake_sim", 0.0), "odds": r.get("odds"), "result": r.get("result")})
            total += pnl
        realized_pnl = total
    roi      = (realized_pnl / total_staked) if total_staked else np.nan
    avg_odds = pd.to_numeric(realized.get("odds", pd.Series(dtype=float)), errors="coerce").mean()
    max_dd   = float(curve["drawdown"].min()) if not curve.empty else 0.0
    return pd.DataFrame([{
        "bets": len(df), "settled": int(settled), "wins": int(wins), "losses": int(losses), "pushes": int(pushes),
        "staked_units": round(total_staked, 2), "realized_pnl": round(realized_pnl, 2),
        "roi": round(roi, 4) if pd.notna(roi) else np.nan,
        "avg_odds": round(float(avg_odds), 2) if pd.notna(avg_odds) else np.nan,
        "max_drawdown": round(max_dd, 2),
    }])

def _infer_season_week(df: pd.DataFrame) -> pd.DataFrame:
    df = df.copy()
    ts = pd.to_datetime(df.get("placed_at").fillna(df.get("ts")), errors="coerce", utc=True)

    s = pd.to_numeric(df.get("season"), errors="coerce")
    df["season"] = s
    if ts is not None:
        df.loc[df["season"].isna(), "season"] = ts.dt.year
    df["season"] = df["season"].astype("Int64")

    w = pd.to_numeric(df.get("week"), errors="coerce")
    if w is None or (hasattr(w, "isna") and w.isna().all()):
        if ts is not None:
            w = ts.dt.isocalendar().week.astype("Int64")
    else:
        w = w.astype("Int64")
    df["week"] = w
    return df

def _preview_seasons_weeks() -> Tuple[List[str], Dict[str, List[int]]]:
    current = dt.datetime.utcnow().year
    seasons = [str(y) for y in range(1966, current + 1)]
    weeks_by_season: Dict[str, List[int]] = {s: list(range(1, 23)) for s in seasons}
    return seasons, weeks_by_season

def apply_policy(df: pd.DataFrame, policy: str, bankroll_start: float, unit_size: float, kelly_frac: float) -> pd.DataFrame:
    if df is None or df.empty:
        return pd.DataFrame(columns=["placed_at","odds","stake","stake_sim","p_win","policy","pnl","result"])
    df = df.copy()
    if "result" not in df.columns:
        df["result"] = np.nan
    df["policy"] = policy
    df["stake_sim"] = 0.0
    rows = []
    for _, r in df.sort_values("placed_at").iterrows():
        p_win = r.get("p_win")
        odds  = r.get("odds")
        if pd.isna(p_win) and pd.notna(odds):
            p_win = implied_prob_from_american(float(odds))
        elif pd.isna(p_win):
            p_win = 0.5
        if policy == "flat_units":
            stake = float(unit_size)
        elif policy == "percent_bankroll":
            stake = float(bankroll_start) * float(unit_size)
        else:
            stake = float(bankroll_start) * float(kelly_fraction(float(p_win), float(odds), fraction=kelly_frac))
        rows.append({**r.to_dict(), "p_win": p_win, "stake_sim": stake})
    out = pd.DataFrame(rows)
    if "result" not in out.columns:
        out["result"] = np.nan
    def _pnl(row):
        base = row if not pd.isna(row.get("stake")) and row.get("stake") not in (None, 0) else {
            "stake": row.get("stake_sim", 0.0), "odds": row.get("odds"), "result": row.get("result")
        }
        pnl, _ = settle_row(base)
        return pnl
    out["pnl"] = out.apply(_pnl, axis=1)
    return out

# ---------------- UI ----------------
st.header("Backtest")

# --- Reactive filters OUTSIDE the form ---
c1, c2, c3 = st.columns([1,1,2])
sport = c1.text_input("Sport (default NFL)", value="NFL")
seasons, _weeks_map = _preview_seasons_weeks()
season_choice = c2.selectbox("Season", options=["All"] + seasons, index=0)

c4, c5 = st.columns([1,3])
market_sel = c4.multiselect(
    "Markets (choose one or more)",
    options=list(_MARKET_GROUPS.keys()),
    default=["Moneyline","Spread","Total (O/U)","Props","Parlay"],
)

week_opts = list(range(1, 23)) if season_choice != "All" else []
week_choice = c5.multiselect(
    "Weeks (if season selected)",
    options=week_opts,
    default=week_opts,
    key=f"weeks_{season_choice}" if season_choice != "All" else "weeks_all",
)
st.caption(f"DEBUG â†’ season={season_choice!s}, week_opts={len(week_opts)}")

# --- Run controls INSIDE the form ---
with st.form("backtest_form_v4"):
    c6, c7 = st.columns([1,1])
    min_edge = c6.number_input("Min edge (%)", min_value=0.0, value=0.0, step=0.25, key="min_edge")
    use_logs = c7.checkbox("Use bets_log.csv + parlays.csv", value=True, key="use_logs")

    c8, c9, c10 = st.columns(3)
    policy   = c8.selectbox("Staking policy", ["flat_units","percent_bankroll","kelly_frac"], index=0, key="policy")
    bankroll = c9.number_input("Starting bankroll (units)", min_value=1.0, value=100.0, step=1.0, key="bankroll")
    if policy == "flat_units":
        unit_size = c10.number_input("Flat unit size", min_value=0.01, value=1.0, step=0.25, key="unit_size_flat")
        k_frac = 0.5
    elif policy == "percent_bankroll":
        unit_size = c10.number_input("Percent of bankroll (e.g., 0.01 = 1%)", min_value=0.0001, max_value=1.0, value=0.01, step=0.005, format="%.4f", key="unit_size_pct")
        k_frac = 0.5
    else:
        unit_size = 1.0
        k_frac = c10.number_input("Kelly fraction", min_value=0.01, max_value=1.0, value=0.5, step=0.05, key="kelly_frac")

    bl_test = _read_csv_safe(EXPORTS / "bets_log.csv")
    pl_test = _read_csv_safe(EXPORTS / "parlays.csv")
    eg_test = _read_csv_safe(EXPORTS / "edges.csv")
    rows_bl = 0 if bl_test is None or bl_test.empty else len(bl_test)
    rows_pl = 0 if pl_test is None or pl_test.empty else len(pl_test)
    rows_eg = 0 if eg_test is None or eg_test.empty else len(eg_test)
    st.caption(f"Data check â†’ bets_log.csv: {rows_bl} | parlays.csv: {rows_pl} | edges.csv: {rows_eg} | exports: {EXPORTS}")
    if rows_bl + rows_pl == 0 and rows_eg > 0 and use_logs:
        use_logs = False
        st.info("Logs are empty; using edges.csv instead.")

    submitted = st.form_submit_button("Run Backtest", key="submit_backtest_v4")

if submitted:
    try:
        # ---- Build base dataframe
        df_list: List[pd.DataFrame] = []
        if use_logs:
            bl = normalize_bets(_read_csv_safe(EXPORTS / "bets_log.csv"), "bets_log")
            pl = normalize_bets(_read_csv_safe(EXPORTS / "parlays.csv"), "parlays")
            df_list += [bl, pl]
        else:
            eg = _read_csv_safe(EXPORTS / "edges.csv")
            if not eg.empty:
                eg = eg.copy()
                eg.columns = [c.lower() for c in eg.columns]
                keep = ["ts","sport","league","game_id","market","ref","side","line","odds","p_win","result"]
                for c in keep:
                    if c not in eg.columns: eg[c] = None
                eg["placed_at"] = pd.to_datetime(eg["ts"], errors="coerce")
                eg["stake"] = 0.0
                df_list.append(eg[keep + ["placed_at","stake"]])

        parts = [d for d in df_list if d is not None and not d.empty]
        base = pd.concat(parts, ignore_index=True) if parts else pd.DataFrame()

        if base.empty:
            st.warning("No data after loading. Try Season=All and Min edge=0.")
        else:
            base.columns = [c.lower() for c in base.columns]
            for col in ("market","sport","league","season","week","result"):
                if col not in base.columns:
                    base[col] = None
            base["market_group"] = base["market"].map(classify_market) if "market" in base.columns else "Other"

            def show_count(label, df):
                st.caption(f"{label}: {len(df)} rows")

            show_count("loaded", base)

            # sport fallback & filter
            if "sport" in base.columns and base["sport"].isna().all() and "league" in base.columns:
                base["sport"] = base["league"]
            elif "sport" in base.columns and "league" in base.columns:
                base["sport"] = base["sport"].fillna(base["league"])

            if str(sport).strip() and "sport" in base.columns and base["sport"].notna().any():
                filtered = base[base["sport"].astype(str).str.contains(str(sport), case=False, na=False)]
                if len(filtered) > 0:
                    base = filtered
                else:
                    st.info(f"No rows match sport '{sport}'. Keeping all sports.")
            show_count("after sport filter", base)

            # infer season/week then season filter
            base = _infer_season_week(base)

            if season_choice != "All" and "season" in base.columns and base["season"].notna().any():
                filtered = base[base["season"].astype(str) == str(season_choice)]
                if len(filtered) > 0:
                    base = filtered
                else:
                    st.info(f"No rows match season {season_choice}. Keeping all seasons.")
            show_count("after season filter", base)
# week filter (smart: skip if weeks look like ISO weeks; keep NAs)
if week_choice and "week" in base.columns:
    wk = pd.to_numeric(base["week"], errors="coerce")
    mx = wk.max(skipna=True)
    if pd.notna(mx) and float(mx) > 22:
        st.info("Week column looks like ISO weeks; skipping week filter.")
    else:
        wk = wk.astype("Int64")
        week_ints = pd.array([int(w) for w in week_choice], dtype="Int64")
        mask = wk.isin(week_ints) | wk.isna()   # keep NAs so we don't nuke rows
        filtered = base[mask]
        if len(filtered) > 0:
            base = filtered
        else:
            st.info("No rows match selected weeks. Keeping all weeks.")
show_count("after week filter", base)

            # market filter
            if market_sel and "market_group" in base.columns:
                filtered = base[base["market_group"].isin(market_sel)]
                if len(filtered) > 0:
                    base = filtered
                else:
                    st.info("No rows match selected markets. Keeping all markets.")
            show_count("after market filter", base)

            # EV / Min edge filter
            # EV / Min edge filter
if "ev" in base.columns:
    ev_num = pd.to_numeric(base["ev"], errors="coerce")
    if ev_num.notna().any():
        filt = (ev_num.fillna(-999) * 100.0) >= float(min_edge)
        filtered = base[filt]
        if len(filtered) > 0 or float(min_edge) == 0.0:
            base = filtered
        else:
            st.info("No rows match Min edge. Keeping all (ignoring Min edge).")
    else:
        st.caption("EV column is empty/NaN for these rows; skipping Min edge filter.")
show_count("after ev filter", base)

            # simulate / outputs
            if base.empty:
                st.warning("No rows to simulate. Try Season=All, Min edge=0, or uncheck logs to use edges.csv.")
            else:
                pol_df = apply_policy(base, policy=policy, bankroll_start=bankroll, unit_size=unit_size, kelly_frac=k_frac)
                if "result" not in pol_df.columns:
                    pol_df["result"] = np.nan

                curve  = bankroll_curve(pol_df, bankroll_start=bankroll)
                summary = summarize(pol_df, curve)

                st.subheader("Summary")
                st.dataframe(summary, use_container_width=True)

                st.subheader("Bankroll curve (realized only)")
                if not curve.empty:
                    st.line_chart(curve.set_index("placed_at")["bankroll"], use_container_width=True)
                else:
                    st.caption("No settled bets to plot.")

                st.subheader("Bets (filtered)")
                show_cols = [c for c in [
                    "placed_at","sport","league","game_id","season","week","market","market_group",
                    "ref","side","line","odds","p_win","ev","stake","stake_sim","result","pnl","policy","tag","src"
                ] if c in pol_df.columns]
                st.dataframe(pol_df[show_cols] if show_cols else pol_df, use_container_width=True)
    except Exception as e:
        st.error(f"Backtest page error: {e}")










