from __future__ import annotations
# === AppImportGuard (nuclear) ===
try:
    from app.lib.auth import login, show_logout
except ModuleNotFoundError:
    import sys
    from pathlib import Path
    here = Path(__file__).resolve()

    base = None
    auth_path = None
    for p in [here] + list(here.parents):
        cand1 = p / "app" / "lib" / "auth.py"
        cand2 = p / "serving_ui" / "app" / "lib" / "auth.py"
        if cand1.exists():
            base, auth_path = p, cand1
            break
        if cand2.exists():
            base, auth_path = (p / "serving_ui"), cand2
            break

    if base and auth_path:
        s = str(base)
        if s not in sys.path:
            sys.path.insert(0, s)
        try:
            from app.lib.auth import login, show_logout  # type: ignore
        except ModuleNotFoundError:
            import types, importlib.util
            if "app" not in sys.modules:
                pkg_app = types.ModuleType("app")
                pkg_app.__path__ = [str(Path(base) / "app")]
                sys.modules["app"] = pkg_app
            if "app.lib" not in sys.modules:
                pkg_lib = types.ModuleType("app.lib")
                pkg_lib.__path__ = [str(Path(base) / "app" / "lib")]
                sys.modules["app.lib"] = pkg_lib
            spec = importlib.util.spec_from_file_location("app.lib.auth", str(auth_path))
            mod = importlib.util.module_from_spec(spec)  # type: ignore[arg-type]
            assert spec and spec.loader
            spec.loader.exec_module(mod)  # type: ignore[attr-defined]
            sys.modules["app.lib.auth"] = mod
            login = mod.login
            show_logout = mod.show_logout
    else:
        raise
# === /AppImportGuard ===


import sys
from pathlib import Path
import streamlit as st
_here = Path(__file__).resolve()
for up in [_here] + list(_here.parents):
    cand = up / 'serving_ui' / 'app' / '__init__.py'
    if cand.exists():
        base = str((up / 'serving_ui').resolve())
        if base not in sys.path:
            sys.path.insert(0, base)
        break
PAGE_PROTECTED = False
auth = login(required=PAGE_PROTECTED)
if not auth.ok:
    st.stop()
show_logout()
auth = login(required=False)
if not auth.authenticated:
    st.info('You are in read-only mode.')
show_logout()
import sys, os
from pathlib import Path
_HERE = Path(__file__).resolve()
_SERVING_UI = _HERE.parents[2]
if str(_SERVING_UI) not in sys.path:
    sys.path.insert(0, str(_SERVING_UI))
from app.lib.access import live_enabled
if live_enabled():
    do_expensive_refresh()
else:
    pass
st.set_page_config(page_title='10 Edge Scanner', page_icon='ðŸ“ˆ', layout='wide')
import os, time, math
from pathlib import Path
from typing import List, Optional, Dict
import numpy as np
import pandas as pd
from app.utils.parlay_ui import selectable_odds_table
from app.utils.parlay_cart import read_cart, clear_cart
try:
    from app.utils.diagnostics import mount_in_sidebar
except ModuleNotFoundError:
    try:
        import sys
        from pathlib import Path as _efP
        sys.path.append(str(_efP(__file__).resolve().parents[3]))
        from app.utils.diagnostics import mount_in_sidebar
    except Exception:
        try:
            from utils.diagnostics import mount_in_sidebar
        except Exception:

            def mount_in_sidebar(page_name: str):
                return None
TZ = 'America/New_York'

def _exports_dir() -> Path:
    env = os.environ.get('EDGE_EXPORTS_DIR', '').strip()
    if env:
        p = Path(env)
        p.mkdir(parents=True, exist_ok=True)
        return p
    here = Path(__file__).resolve()
    for up in [here.parent] + list(here.parents):
        if up.name.lower() == 'edge-finder':
            p = up / 'exports'
            p.mkdir(parents=True, exist_ok=True)
            return p
    p = Path.cwd() / 'exports'
    p.mkdir(parents=True, exist_ok=True)
    return p

def _age_str(p: Path) -> str:
    try:
        secs = int(time.time() - p.stat().st_mtime)
        return f'{secs}s' if secs < 60 else f'{secs // 60}m'
    except Exception:
        return 'n/a'
_ALIAS = {'REDSKINS': 'COMMANDERS', 'WASHINGTON': 'COMMANDERS', 'FOOTBALL': 'COMMANDERS', 'OAKLAND': 'RAIDERS', 'LV': 'RAIDERS', 'LAS': 'RAIDERS', 'VEGAS': 'RAIDERS', 'SD': 'CHARGERS', 'STL': 'RAMS'}

def _nickify(series: pd.Series) -> pd.Series:
    s = series.astype('string').fillna('').str.upper()
    s = s.str.replace('[^A-Z0-9 ]+', '', regex=True).str.strip().replace(_ALIAS)
    return s.str.replace('\\s+', '_', regex=True)

def _best_col(df: pd.DataFrame, candidates: List[str]) -> Optional[str]:
    low = {c.lower(): c for c in df.columns}
    for c in candidates:
        if c.lower() in low:
            return low[c.lower()]
    return None

def _ensure_nicks(df: pd.DataFrame) -> pd.DataFrame:
    if df.empty:
        return df
    home_c = _best_col(df, ['_home_nick', 'home_nick', 'home', 'home_team', 'Home', 'HOME', 'team_home'])
    away_c = _best_col(df, ['_away_nick', 'away_nick', 'away', 'away_team', 'Away', 'AWAY', 'team_away'])
    if home_c is None:
        df['_home_nick'] = pd.Series([''] * len(df), dtype='string')
    else:
        df['_home_nick'] = _nickify(df[home_c].astype('string'))
    if away_c is None:
        df['_away_nick'] = pd.Series([''] * len(df), dtype='string')
    else:
        df['_away_nick'] = _nickify(df[away_c].astype('string'))
    return df

def _norm_market(m) -> str:
    m = (str(m) or '').strip().lower()
    if m in {'h2h', 'ml', 'moneyline', 'money line'}:
        return 'H2H'
    if m.startswith('spread') or m in {'spread', 'spreads'}:
        return 'SPREADS'
    if m.startswith('total') or m in {'total', 'totals'}:
        return 'TOTALS'
    return m.upper()

def _odds_to_decimal(o: pd.Series) -> pd.Series:
    o = pd.to_numeric(o, errors='coerce')
    return np.where(o > 0, 1 + o / 100.0, np.where(o < 0, 1 + 100.0 / np.abs(o), np.nan))

def _ensure_date_iso(df: pd.DataFrame, candidates: List[str]) -> pd.DataFrame:
    if len(df) == 0:
        return df
    for c in candidates:
        if c in df.columns:
            s = pd.to_datetime(df[c], errors='coerce', utc=True)
            df['_date_iso'] = s.dt.tz_convert(TZ).dt.strftime('%Y-%m-%d')
            break
    if '_date_iso' not in df.columns:
        df['_date_iso'] = pd.Series(pd.NA, index=df.index, dtype='string')
    return df

def latest_batch(df: pd.DataFrame) -> pd.DataFrame:
    if df is None or df.empty:
        return df
    for col in ['_snapshot_ts_utc', 'snapshot_ts_utc', 'snapshot_ts', '_ts', 'ts']:
        if col in df.columns:
            ts = pd.to_datetime(df[col], errors='coerce', utc=True)
            last = ts.max()
            return df[ts == last].copy()
    return df

def within_next_week(df: pd.DataFrame) -> pd.DataFrame:
    if df is None or df.empty:
        return df
    if '_date_iso' not in df.columns:
        return df
    d = pd.to_datetime(df['_date_iso'], errors='coerce', utc=True).dt.tz_convert(TZ)
    today = pd.Timestamp.now(tz=TZ).normalize()
    end = today + pd.Timedelta(days=7)
    return df[(d >= today) & (d <= end)].copy()

def refresh_button(key: Optional[str]=None):
    if st.button('ðŸ”„ Refresh data', key=key or f'refresh_{__name__}'):
        try:
            st.cache_data.clear()
        except Exception:
            pass
        st.rerun()

def _latest_csv(paths: list[Path]) -> Optional[Path]:
    paths = [p for p in paths if p and p.exists()]
    if not paths:
        return None
    return max(paths, key=lambda p: p.stat().st_mtime)

@st.cache_data(ttl=60)
def load_live() -> tuple[pd.DataFrame, Path]:
    exp = _exports_dir()
    cand = [exp / 'lines_live.csv', exp / 'lines_live_latest.csv']
    p = _latest_csv(cand) or cand[0]
    df = pd.read_csv(p, low_memory=False, encoding='utf-8-sig') if p.exists() else pd.DataFrame()
    return (df, p)

@st.cache_data(ttl=60)
def load_open_close() -> tuple[pd.DataFrame, Path]:
    exp = _exports_dir()
    cand = [exp / 'lines_open_close.csv', exp / 'lines_open_close_latest.csv']
    p = _latest_csv(cand) or cand[0]
    df = pd.read_csv(p, low_memory=False, encoding='utf-8-sig') if p.exists() else pd.DataFrame()
    return (df, p)

@st.cache_data(ttl=60)
def load_edges() -> tuple[pd.DataFrame, Path]:
    exp = _exports_dir()
    names = ['edges_standardized.csv', 'edges_graded_full_normalized_std.csv', 'edges_graded_full.csv', 'edges_normalized.csv', 'edges_master.csv']
    paths = [exp / n for n in names]
    p = _latest_csv(paths) or paths[0]
    df = pd.read_csv(p, low_memory=False, encoding='utf-8-sig') if p.exists() else pd.DataFrame()
    return (df, p)
diag = mount_in_sidebar('10_Edge_Scanner')
st.title('Edge Scanner')
refresh_button(key='refresh_10_scanner')
edges, edges_p = load_edges()
st.caption(f'Edges: `{edges_p}` Â· rows={len(edges):,}')
if edges.empty:
    st.stop()

def american_to_prob(o):
    if pd.isna(o):
        return np.nan
    o = float(o)
    return 100.0 / (o + 100.0) if o > 0 else abs(o) / (abs(o) + 100.0) if o < 0 else np.nan

def american_to_payout(o):
    if pd.isna(o):
        return np.nan
    o = float(o)
    return o / 100.0 if o > 0 else 100.0 / abs(o)
odds = pd.to_numeric(edges.get('odds', edges.get('price', pd.Series(index=edges.index))), errors='coerce')
pwin = pd.to_numeric(edges.get('p_win', pd.Series(index=edges.index)), errors='coerce')
pwin = pwin.where(pwin.notna(), odds.map(american_to_prob))
edges = edges.copy()
edges['odds'] = odds
edges['p_win'] = pwin
edges['_payout_per_$1'] = odds.map(american_to_payout)
edges['ev/$1'] = edges['p_win'] * edges['_payout_per_$1'] - (1 - edges['p_win'])
left, right = st.columns(2)
with left:
    min_ev = st.slider('Min EV (per $1)', 0.0, 1.0, 0.0, 0.05)
with right:
    min_p = st.slider('Min p_win (implied)', 0.0, 1.0, 0.45, 0.01)
flt = (edges['ev/$1'].fillna(-9) >= min_ev) & (edges['p_win'].fillna(0) >= min_p)
view = edges.loc[flt].copy()
cols = [c for c in ['game_id', 'market', 'side', 'book', 'odds', 'p_win', 'ev/$1'] if c in view.columns]
st.dataframe(view[cols].reset_index(drop=True), height=520, width='stretch')
st.caption(f'Rows after filters: {len(view):,}')
st.download_button('Download filtered edges.csv', view[cols].to_csv(index=False).encode('utf-8'), file_name='edges_live_filtered.csv', mime='text/csv')
try:
    import pandas as _ef_pd
    from pathlib import Path as _ef_Path
    _ef = locals().get('diag', None)
    if _ef:
        for _nm in ('edges_p', 'live_p', 'oc_path', 'edges_path', 'live_path', 'scores_path', 'scores_p', 'epath', 'spath', '_lines_p', '_edges_p'):
            _p = locals().get(_nm, None)
            if _p:
                try:
                    _ef.check_file(_ef_Path(str(_p)), required=False, label=_nm)
                except Exception:
                    pass
        for _dfn in ('edges', 'live', 'oc', 'scores', 'joined', 'view'):
            _df = locals().get(_dfn, None)
            try:
                if isinstance(_df, _ef_pd.DataFrame):
                    _ef.log_df(_df, _dfn)
            except Exception:
                pass
except Exception:
    pass
try:
    if 'edges' in globals() and isinstance(edges, pd.DataFrame):
        selectable_odds_table(edges, page_key='edge_scanner', page_name='10_Edge_Scanner')
except Exception:
    pass




