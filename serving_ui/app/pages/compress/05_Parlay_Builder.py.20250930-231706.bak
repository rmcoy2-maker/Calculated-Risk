from __future__ import annotations
# === AppImportGuard (nuclear) ===
try:
    from app.lib.auth import login, show_logout
except ModuleNotFoundError:
    import sys
    from pathlib import Path
    here = Path(__file__).resolve()

    base = None
    auth_path = None
    for p in [here] + list(here.parents):
        cand1 = p / "app" / "lib" / "auth.py"
        cand2 = p / "serving_ui" / "app" / "lib" / "auth.py"
        if cand1.exists():
            base, auth_path = p, cand1
            break
        if cand2.exists():
            base, auth_path = (p / "serving_ui"), cand2
            break

    if base and auth_path:
        s = str(base)
        if s not in sys.path:
            sys.path.insert(0, s)
        try:
            from app.lib.auth import login, show_logout  # type: ignore
        except ModuleNotFoundError:
            import types, importlib.util
            if "app" not in sys.modules:
                pkg_app = types.ModuleType("app")
                pkg_app.__path__ = [str(Path(base) / "app")]
                sys.modules["app"] = pkg_app
            if "app.lib" not in sys.modules:
                pkg_lib = types.ModuleType("app.lib")
                pkg_lib.__path__ = [str(Path(base) / "app" / "lib")]
                sys.modules["app.lib"] = pkg_lib
            spec = importlib.util.spec_from_file_location("app.lib.auth", str(auth_path))
            mod = importlib.util.module_from_spec(spec)  # type: ignore[arg-type]
            assert spec and spec.loader
            spec.loader.exec_module(mod)  # type: ignore[attr-defined]
            sys.modules["app.lib.auth"] = mod
            login = mod.login
            show_logout = mod.show_logout
    else:
        raise
# === /AppImportGuard ===


import streamlit as st
auth = login(required=False)
if not auth.authenticated:
    st.info('You are in read-only mode.')
show_logout()
import os
from pathlib import Path
from datetime import datetime
import numpy as np
import pandas as pd
_st = st

def american_to_decimal(o):
    try:
        o = float(o)
    except Exception:
        return np.nan
    if o > 0:
        return 1.0 + o / 100.0
    if o < 0:
        return 1.0 + 100.0 / abs(o)
    return np.nan

def american_to_prob(o):
    try:
        o = float(o)
    except Exception:
        return np.nan
    if o > 0:
        return 100.0 / (o + 100.0)
    if o < 0:
        return abs(o) / (abs(o) + 100.0)
    return np.nan

def to_numeric(s):
    return pd.to_numeric(s, errors='coerce')

def norm_market(m: str) -> str:
    m = (str(m) if m is not None else '').strip().lower()
    if m in ('h2h', 'ml', 'moneyline', 'money line'):
        return 'H2H'
    if m.startswith('spread'):
        return 'SPREADS'
    if m.startswith('total'):
        return 'TOTALS'
    return m.upper()

def _normalize_team_text(s):
    if not isinstance(s, str) or not s.strip():
        return ''
    return s.strip().upper()

def _to_nick(s):
    s = _normalize_team_text(s)
    return s.split()[-1] if s else ''

def _col(df, names, default=None):
    for n in names:
        if n in df.columns:
            return df[n]
    return pd.Series([default] * len(df))

def find_exports_dir() -> Path:
    env = os.environ.get('EDGE_EXPORTS_DIR', '').strip()
    if env:
        p = Path(env)
        if p.exists():
            return p
    here = Path.cwd()
    for up in [here] + list(here.parents)[:5]:
        cand = up / 'exports'
        if cand.exists():
            return cand
    common = [here / 'exports', here / '..' / 'exports', here / 'serving_ui' / 'exports', here / 'app' / 'exports', Path(__file__).resolve().parent.parent.parent / 'exports']
    for c in common:
        try:
            if c.exists():
                return c
        except Exception:
            pass
    return here

@st.cache_data(ttl=30, show_spinner=False)
def autoload_edges(with_caption: bool=True):
    root = find_exports_dir()
    env_path = os.environ.get('EDGE_SOURCE_FILE')
    candidates = []
    if env_path:
        p = Path(env_path)
        candidates.append(p if p.is_absolute() else Path.cwd() / env_path)
    candidates += [root / 'edges_graded_full.csv', root / 'edges_graded_plus.csv', root / 'edges_graded.csv', root / 'edges.csv', root / 'lines_live.csv']
    picked_path = None
    df = pd.DataFrame()
    for p in candidates:
        try:
            if p.exists() and p.stat().st_size > 0:
                tmp = pd.read_csv(p, low_memory=False, encoding='utf-8-sig')
                if not tmp.empty:
                    picked_path = p
                    df = tmp
                    break
        except Exception:
            continue
    if with_caption:
        st.caption(f"Loaded: {picked_path or '—'} · exports root: {root or '(not found)'} · rows={len(df):,} · cols={len(df.columns)}")
    return (df, str(picked_path) if picked_path else None, str(root))
st.title('Parlay Builder')
col_a, col_b = st.columns([1, 3])
with col_a:
    if st.button('Force reload', help='Clear caches and reload file candidates'):
        try:
            autoload_edges.clear()
        except Exception:
            pass
        st.experimental_rerun()
with col_b:
    exp_dir = find_exports_dir()
    st.caption(f"exports dir → {exp_dir}  |  EDGE_SOURCE_FILE → {os.environ.get('EDGE_SOURCE_FILE', '(not set)')}")
_cands = [('edges_graded_full.csv', find_exports_dir() / 'edges_graded_full.csv'), ('edges_graded_plus.csv', find_exports_dir() / 'edges_graded_plus.csv'), ('edges_graded.csv', find_exports_dir() / 'edges_graded.csv'), ('edges.csv', find_exports_dir() / 'edges.csv'), ('lines_live.csv', find_exports_dir() / 'lines_live.csv')]
diag = []
for name, p in _cands:
    try:
        diag.append({'file': name, 'exists': 'yes' if p.exists() else 'no', 'size_bytes': int(p.stat().st_size) if p.exists() else 0, 'full_path': str(p if p.exists() else '')})
    except Exception:
        diag.append({'file': name, 'exists': 'error', 'size_bytes': 0, 'full_path': ''})
st.dataframe(pd.DataFrame(diag), height=180, width='stretch')
edges, edges_path, root_path = autoload_edges(with_caption=True)
if edges.empty:
    st.stop()
edges = edges.copy()
edges['market_norm'] = _col(edges, ['market', 'Market']).map(norm_market)
edges['_odds'] = _col(edges, ['odds', 'price_american', 'Odds', 'american_odds'])
edges['_odds'] = to_numeric(edges['_odds'])

def parse_date_from_any(df: pd.DataFrame) -> pd.Series:
    for c in ['commence_time', 'CommenceTime', 'Date', '_date', 'game_date']:
        if c in df.columns:
            dt = pd.to_datetime(df[c], errors='coerce', utc=True).dt.tz_convert(None)
            if dt.notna().any():
                return dt.dt.date
    if 'game_id' in df.columns:
        m = df['game_id'].astype(str).str.extract('(\\d{4}-\\d{2}-\\d{2})', expand=False)
        dt = pd.to_datetime(m, errors='coerce')
        return dt.dt.date
    return pd.Series([pd.NaT] * len(df))
edges['_date'] = parse_date_from_any(edges)
edges['_home_raw'] = _col(edges, ['home', 'HomeTeam', '_home_team', '_home_abbr', '_home_abbr_norm', 'home_team'], '')
edges['_away_raw'] = _col(edges, ['away', 'AwayTeam', '_away_team', '_away_abbr', '_away_abbr_norm', 'away_team'], '')
edges['_home_nick'] = edges['_home_raw'].map(_to_nick)
edges['_away_nick'] = edges['_away_raw'].map(_to_nick)
side_raw = _col(edges, ['selection', 'Selection', 'side', 'team', '_pick_team'], '').astype(str)
edges['_side_raw'] = side_raw
is_totals = edges['market_norm'].eq('TOTALS')
edges['_side'] = np.where(is_totals, side_raw.str.strip().str.title().map({'Over': 'Over', 'Under': 'Under'}), side_raw.map(_to_nick))
p_model = _col(edges, ['p_model', 'p_pred'])
p_win = _col(edges, ['p_win', 'prob', 'prob_win'])
edges['_p_implied'] = edges['_odds'].map(american_to_prob)
edges['_p_win'] = np.where(~p_model.isna(), p_model, np.where(~p_win.isna(), p_win, edges['_p_implied']))
edges['_p_win'] = pd.to_numeric(edges['_p_win'], errors='coerce').clip(0, 1)
edges['_dec'] = edges['_odds'].map(american_to_decimal)
edges['_payout_per_$1'] = edges['_dec'] - 1.0
edges['_ev_per_$1'] = edges['_p_win'] * edges['_payout_per_$1'] - (1.0 - edges['_p_win'])

def _date_to_str(d):
    try:
        return d.isoformat()
    except Exception:
        return str(d) if d is not None else ''
edges['_game_key'] = edges['_date'].map(_date_to_str) + '::' + edges['_home_nick'].fillna('') + '@' + edges['_away_nick'].fillna('')
st.sidebar.subheader('Filters')
min_prob = st.sidebar.slider('Min P(win)', 0.4, 0.8, 0.5, 0.01)
min_abs_american = st.sidebar.slider('Min |odds|', 100, 300, 110, 5)
allowed_markets = st.sidebar.multiselect('Markets', ['H2H', 'SPREADS', 'TOTALS'], default=['H2H', 'SPREADS', 'TOTALS'])
per_game_cap = st.sidebar.slider('Max legs per game', 1, 2, 1, 1)
min_legs, max_legs = (3, 10)
desired_legs = st.sidebar.slider('Desired legs', min_legs, max_legs, 5, 1)
filt = edges['market_norm'].isin(allowed_markets) & edges['_p_win'].ge(min_prob) & edges['_odds'].abs().ge(min_abs_american)
work = edges.loc[filt].copy()
st.caption(f"rows={len(work):,} · market mix={work['market_norm'].value_counts().to_dict()}")
if work.empty:
    st.warning('No legs meet your filters. Loosen thresholds.')
    st.stop()
work = work.sort_values(['_ev_per_$1', '_p_win'], ascending=[False, False]).copy()
sel_rows, per_game_counts = ([], {})
for _, r in work.iterrows():
    g = r['_game_key']
    if per_game_counts.get(g, 0) >= per_game_cap:
        continue
    sel_rows.append(r)
    per_game_counts[g] = per_game_counts.get(g, 0) + 1
    if len(sel_rows) >= desired_legs:
        break
sel = pd.DataFrame(sel_rows)
if len(sel) < min_legs:
    st.warning(f'Need at least {min_legs} legs at current filters/caps. Only {len(sel)} available.')
    st.stop()
leg_probs = sel['_p_win'].fillna(0).clip(0, 1).to_list()
win_prob = float(np.prod(leg_probs)) if leg_probs else 0.0
decs = sel['_dec'].fillna(1.0).to_list()
combo_dec = float(np.prod(decs)) if decs else 1.0
payout_per_1 = max(combo_dec - 1.0, 0.0)
ev_per_1 = win_prob * payout_per_1 - (1.0 - win_prob)
st.subheader('Your Parlay')
show_cols = [c for c in ['_date', 'market_norm', '_side', '_odds', '_p_win', '_ev_per_$1', '_home_raw', '_away_raw'] if c in sel.columns]
st.dataframe(sel[show_cols].rename(columns={'_date': 'Date', 'market_norm': 'Market', '_side': 'Side', '_odds': 'Odds (US)', '_p_win': 'P(win)', '_ev_per_$1': 'EV per $1', '_home_raw': 'Home', '_away_raw': 'Away'}), width='stretch')
st.markdown(f'**Combined P(win):** {win_prob:.4f}  \n**Combined Decimal Odds:** {combo_dec:.4f}  \n**Payout per $1:** {payout_per_1:.4f}  \n**EV per $1:** {ev_per_1:.4f}')
if st.button('Export parlay legs to CSV', width='stretch'):
    ts = datetime.now().strftime('%Y%m%d_%H%M%S')
    out = find_exports_dir() / f'parlay_selection_{ts}.csv'
    sel.to_csv(out, index=False, encoding='utf-8-sig')
    st.success(f'Saved: {out}')
try:

    def _american_to_prob(x):
        try:
            o = float(x)
        except Exception:
            return None
        return 100.0 / (o + 100.0) if o > 0 else -o / (-o + 100.0)
    if '_p_implied' not in edges.columns and 'odds' in edges.columns:
        edges['_p_implied'] = pd.to_numeric(edges['odds'], errors='coerce').map(_american_to_prob)
    if '_p_win' in edges.columns and '_p_implied' in edges.columns:
        edges['_edge'] = edges['_p_win'] - edges['_p_implied']
    if 'sel' in globals():
        _cols = [c for c in ['_p_win', '_p_implied', '_edge', '_ev_per_$1'] if c in sel.columns]
        if _cols:
            with _st.expander('Model vs House (quick view)'):
                _st.dataframe(sel[_cols].head(50), width='stretch')
except Exception:
    pass

# === Nudge (auto-injected) ===
try:
    from app.utils.nudge import bump_usage, show_nudge  # type: ignore
except Exception:
    bump_usage = lambda *a, **k: None
    def show_nudge(*a, **k): pass

# Count a lightweight interaction per page load
bump_usage("page_visit")

# Show a nudge once usage crosses threshold in the last 24h
show_nudge(feature="analytics", metric="page_visit", threshold=10, period="1D", demo_unlock=True, location="inline")
# === /Nudge (auto-injected) ===

