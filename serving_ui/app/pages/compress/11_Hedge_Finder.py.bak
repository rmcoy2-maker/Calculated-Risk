# -*- coding: utf-8 -*-
from __future__ import annotations
import pandas as pd
import numpy as np
import streamlit as st

# Load edges EARLY so `df` exists before any code touches it
try:
    from lib.io_paths import autoload_edges
    df, df_path, root_path = autoload_edges(with_caption=True)
    if df is None:
        df = pd.DataFrame()
except Exception:
    df = pd.DataFrame()

# If you reference 'key' immediately, define it now (adjust as needed)
key = ["Season", "Week", "market", "_pick_team", "odds", "p_win", "p_model", "stake", "parlay_id"]
have = [k for k in key if k in df.columns]


# ensure df exists for diagnostics/filters that run at import time
try:
    from lib.io_paths import autoload_edges
    _df_loaded, _df_path, _root_path = autoload_edges(with_caption=True)
    df = _df_loaded if _df_loaded is not None else pd.DataFrame()
except Exception:
    # ultra-safe fallback
    df = pd.DataFrame()

from itertools import combinations
from lib.io_paths import autoload_edges, clear_loader_cache
from lib.enrich import add_probs_and_ev, attach_teams
key = ["game_id","market","side"]
have = [k for k in key if k in df.columns]
if len(have)==3:
    grp = df.dropna(subset=have+["odds"]).groupby(have, dropna=False)
    best_buy  = grp["odds"].max().rename("odds_max")
    best_lay  = grp["odds"].min().rename("odds_min")
    spread = pd.concat([best_buy, best_lay], axis=1)
    spread["window"] = (spread["odds_max"].abs() + spread["odds_min"].abs()) # simple check
    # join back the specific rows for the two books if you want to list the pair
    candidates = spread.query("odds_max > 0 and odds_min < 0")  # classic + vs -
else:
    candidates = pd.DataFrame()

df, df_path, root = autoload_edges(with_caption=True)
df = add_probs_and_ev(attach_teams(df))

st.set_page_config(page_title="Hedge Finder", page_icon="ðŸª™", layout="wide")
st.subheader("Hedge Finder")
if st.button("Refresh data", type="primary", use_container_width=False):
    clear_loader_cache(); st.rerun()
df, df_path, root_path = autoload_edges(with_caption=True)
if df.empty: st.stop()
for need in ["game_id", "market", "side", "book", "odds"]:
    if need not in df.columns: df[need] = pd.NA
df["odds"] = pd.to_numeric(df["odds"], errors="coerce")
if "sort_ts" in df.columns:
    try: df["sort_ts"] = pd.to_datetime(df["sort_ts"], errors="coerce")
    except Exception: pass
top = st.columns([1, 1.2, 2, 1])
with top[0]: newest_first = st.toggle("Newest first", value=True)
with top[1]: mode = st.selectbox("Side match", ["Strict (OU/Home-Away)", "Loose (any different)"], index=1)
with top[2]: odds_min, odds_max = st.slider("Odds window (American, abs)", 100, 300, (100, 200))
with top[3]: run = st.button("Find hedges", type="primary", use_container_width=True)
if newest_first and "sort_ts" in df.columns and df["sort_ts"].notna().any():
    df = df.sort_values("sort_ts", ascending=False, na_position="last")
games = df["game_id"].dropna().astype(str).unique().tolist()
game = st.selectbox("Game", ["All"] + games)
subset = df if game == "All" else df[df["game_id"].astype(str) == game]
subset = subset[subset["odds"].abs().between(odds_min, odds_max, inclusive="both")]
def is_opposite(a: str, b: str, mode: str) -> bool:
    if not a or not b: return False
    A, B = str(a).strip().lower(), str(b).strip().lower()
    if mode == "Strict (OU/Home-Away)": return (A,B) in {("over","under"),("home","away"),("away","home")} or (B,A) in {("over","under"),("home","away"),("away","home")}
    return A != B
if not run: st.info("Adjust filters and click **Find hedges**."); st.stop()
rows = []
for (gid, mkt), g in subset.groupby(["game_id", "market"], dropna=False):
    g = g.reset_index(drop=True)
    for i, j in combinations(range(len(g)), 2):
        a, b = g.loc[i], g.loc[j]
        if is_opposite(a.get("side", ""), b.get("side", ""), mode):
            rows.append({"game_id": str(gid), "market": str(mkt),
                         "a_side": str(a.get("side", "")), "a_odds": a.get("odds"), "a_book": str(a.get("book", "")),
                         "b_side": str(b.get("side", "")), "b_odds": b.get("odds"), "b_book": str(b.get("book", ""))})
if not rows: st.info("No hedges found at current filters.")
else:
    out = pd.DataFrame(rows)
    st.dataframe(out, use_container_width=True)
    st.download_button("Download hedges.csv", data=out.to_csv(index=False).encode("utf-8"), file_name="hedges.csv", mime="text/csv")

