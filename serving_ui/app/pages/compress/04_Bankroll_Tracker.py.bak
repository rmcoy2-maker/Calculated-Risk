from __future__ import annotations
import streamlit as st
try:
    pass
except Exception:
    pass
st.markdown("""
<style>
  .block-container { max-width: none !important; padding-left: 1rem; padding-right: 1rem; }
  [data-testid="stHeader"] { z-index: 9990; }
</style>
""", unsafe_allow_html=True)
# --- auto-added: newest-first patch ---

try:
    # Preferred absolute import (when 'app' is a proper package)
    from app.utils.newest_first_patch import apply_newest_first_patch as __nfp_apply
except Exception:
    try:
        # Fallback if pages are executed such that relative path works
        from utils.newest_first_patch import apply_newest_first_patch as __nfp_apply
    except Exception:
        # Final no-op guard
        def __nfp_apply(_): 
            return
import streamlit as st  # ensure alias available
__nfp_apply(st)
# --- end auto-added ---
# ---- PATH SHIM (auto-added) ----
import sys, pathlib
_APP_DIR = pathlib.Path(__file__).resolve().parents[1]  # ...\serving_ui\app
_PARENT  = _APP_DIR.parent                              # ...\serving_ui
if str(_PARENT) not in sys.path:
    sys.path.insert(0, str(_PARENT))
# ---- END PATH SHIM ----
try:
    from app.bootstrap import bootstrap_paths
except ModuleNotFoundError:
    try:
        from bootstrap import bootstrap_paths
    except Exception:
        def bootstrap_paths():  # no-op fallback
            return None; bootstrap_paths()
import sys as _sys
from pathlib import Path as _Path
try:
    _ROOT = _Path(__file__).resolve().parents[2]   # .../serving_ui/app
    _REPO = _ROOT.parents[1]
    if str(_REPO) not in _sys.path:
        _sys.path.insert(0, str(_REPO))
except Exception:
    pass
# === end boot ===# -*- coding: utf-8 -*-
# app/pages/04_Bankroll_Tracker.py (CLEANED)
#
# - Robust date parsing: accepts columns named one of
#   ["date","placed_at","ts","timestamp","time"] and handles epoch sec/ms
# - Safe column normalization for ["bankroll","note","tag"]
# - Summary metrics: current bankroll, 7d change, 30d change, max drawdown
# - Charts: bankroll over time, daily change distribution
#
# CSV expected: exports/bankroll.csv (flexible schema; at minimum one date-like column
# and one "bankroll" numeric column).

import sys, math, datetime as dt
from pathlib import Path
import numpy as np
import pandas as pd
import streamlit as st

# ---------- path bootstrap ----------
ROOT = Path(__file__).resolve().parents[2]
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))

EXPORTS = ROOT / "exports"
EXPORTS.mkdir(parents=True, exist_ok=True)
BANKROLL_CSV = EXPORTS / "bankroll.csv"

# ---------- helpers ----------
def _read_csv_safe(p: Path) -> pd.DataFrame:
    if not p.exists() or p.stat().st_size == 0:
        return pd.DataFrame()
    for enc in (None, "utf-8", "utf-8-sig"):
        try:
            return pd.read_csv(p, encoding=enc) if enc else pd.read_csv(p)
        except Exception:
            continue
    return pd.DataFrame()

def _to_datetime_series(s: pd.Series) -> pd.Series:
    # handle numeric epochs or strings
    s_num = pd.to_numeric(s, errors="coerce")
    if s_num.notna().any():
        epoch_ms = s_num > 1e11
        dt_vals = pd.to_datetime(
            np.where(epoch_ms, s_num, s_num * 1000.0),
            errors="coerce",
            unit="ms",
            utc=True,
        ).tz_convert(None)
        if dt_vals.notna().sum() == 0:
            dt_vals = pd.to_datetime(s, errors="coerce")
        return dt_vals
    return pd.to_datetime(s, errors="coerce")

def _prep_bankroll(df: pd.DataFrame) -> pd.DataFrame:
    if df is None or df.empty:
        return pd.DataFrame(columns=["date","bankroll","note","tag"])

    d = df.copy()
    # normalize columns
    d.columns = [str(c).strip().lower() for c in d.columns]

    # locate a date-like column
    date_candidates = ["date", "placed_at", "ts", "timestamp", "time"]
    date_col = next((c for c in date_candidates if c in d.columns), None)

    if date_col is None:
        # If index is datetime-like, use it; else synthesize today
        if isinstance(d.index, pd.DatetimeIndex):
            d["date"] = d.index.tz_localize(None)
        else:
            # best-effort: if there's a single column that looks like dates in strings
            for c in d.columns:
                try_dt = pd.to_datetime(d[c], errors="coerce")
                if try_dt.notna().any():
                    d["date"] = try_dt
                    break
            if "date" not in d.columns:
                d["date"] = pd.Timestamp.today().normalize()
    else:
        d["date"] = _to_datetime_series(d[date_col])

    # ensure key columns exist
    for col in ["bankroll","note","tag"]:
        if col not in d.columns:
            d[col] = None

    # coerce bankroll numeric
    d["bankroll"] = pd.to_numeric(d["bankroll"], errors="coerce")

    # drop rows with no date OR no bankroll
    d = d.dropna(subset=["date"])
    # If bankroll all NaN, keep empty schema
    if d["bankroll"].notna().sum() == 0:
        return d[["date","bankroll","note","tag"]].iloc[0:0]

    # sort and de-dup on date (keep last per day)
    d = d.sort_values("date").drop_duplicates(subset=["date"], keep="last")

    # add daily change
    d["daily_change"] = d["bankroll"].diff()

    return d[["date","bankroll","daily_change","note","tag"]]

def _drawdown(curve: pd.Series) -> pd.Series:
    # drawdown = value - running max (â‰¤ 0)
    running_max = curve.cummax()
    return curve - running_max

# ---------- UI ----------
st.title("ðŸ’° Bankroll Tracker")

df_raw = _read_csv_safe(BANKROLL_CSV)
df = _prep_bankroll(df_raw)

if df.empty:
    st.warning(f"No bankroll data found at: {BANKROLL_CSV}")
    st.caption("Tip: create exports/bankroll.csv with columns like: date, bankroll, note")
else:
    df = df.copy()
    df["date"] = pd.to_datetime(df["date"], errors="coerce")
    df = df.dropna(subset=["date"]).sort_values("date")
    df["date_only"] = df["date"].dt.date

    # Summary metrics
    latest = df.iloc[-1]
    now_val = float(latest["bankroll"])

    # 7d and 30d changes (compare to nearest past date)
    def _change_since(days: int) -> float | None:
        cutoff = latest["date"] - pd.Timedelta(days=days)
        past = df[df["date"] <= cutoff]
        if past.empty:
            return None
        past_val = float(past.iloc[-1]["bankroll"])
        return now_val - past_val

    delta_7 = _change_since(7)
    delta_30 = _change_since(30)

    # drawdown on bankroll series
    dd = _drawdown(df["bankroll"])
    max_dd = float(dd.min()) if not dd.empty else 0.0

    c1, c2, c3, c4 = st.columns(4)
    c1.metric("Current bankroll", f"{now_val:,.2f}")
    c2.metric("Change (7d)", f"{(delta_7 or 0):+.2f}")
    c3.metric("Change (30d)", f"{(delta_30 or 0):+.2f}")
    c4.metric("Max drawdown", f"{max_dd:,.2f}")

    # Chart
    st.subheader("Bankroll over time")
    st.line_chart(df.set_index("date")["bankroll"], use_container_width=True)

    # Daily change distribution
    st.subheader("Daily changes")
    st.bar_chart(df.set_index("date")["daily_change"].fillna(0.0), use_container_width=True)

    # Raw table
    st.subheader("History")
    show_cols = ["date","bankroll","daily_change","note","tag"]
    st.dataframe(df[show_cols], use_container_width=True, hide_index=True)
















