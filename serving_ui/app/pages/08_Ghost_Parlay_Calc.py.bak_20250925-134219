from __future__ import annotations
import streamlit as st
try:
    pass
except Exception:
    pass
st.markdown("""
<style>
  .block-container { max-width: none !important; padding-left: 1rem; padding-right: 1rem; }
  [data-testid="stHeader"] { z-index: 9990; }
</style>
""", unsafe_allow_html=True)
# --- auto-added: newest-first patch ---

try:
    # Preferred absolute import (when 'app' is a proper package)
    from app.utils.newest_first_patch import apply_newest_first_patch as __nfp_apply
except Exception:
    try:
        # Fallback if pages are executed such that relative path works
        from utils.newest_first_patch import apply_newest_first_patch as __nfp_apply
    except Exception:
        # Final no-op guard
        def __nfp_apply(_): 
            return
import streamlit as st  # ensure alias available
__nfp_apply(st)
# --- end auto-added ---
from app.bootstrap import bootstrap_paths; bootstrap_paths()
import os, sys, json
from dataclasses import dataclass
from itertools import combinations
from pathlib import Path
from typing import List, Tuple, Dict, Any

import pandas as pd
import streamlit as st
import inspect
from datetime import datetime
# --- session state setup ---
if "ghost_res_df" not in st.session_state:
    st.session_state["ghost_res_df"] = None
if "ghost_sel" not in st.session_state:
    st.session_state["ghost_sel"] = []


def _row_to_leg_kwargs(row: dict) -> dict:
    # alias map
    aliases = {"gid": "game_id", "matchup": "game_id"}
    r = {aliases.get(k, k): v for k, v in row.items()}

    # keep only params that Leg accepts
    allowed = set(inspect.signature(Leg).parameters.keys())
    kw = {k: v for k, v in r.items() if k in allowed}

    # light coercions (only if present)
    # odds as INT; line/p_win/stake as FLOAT
    if "odds" in kw:
        try:
            kw["odds"] = int(float(kw["odds"]))
        except Exception:
            pass
    for k in ("line", "p_win", "stake"):
        if k in kw:
            try:
                kw[k] = float(kw[k])
            except Exception:
                pass
    for k in ("ts", "placed_at"):
        if k in kw:
            try:
                kw[k] = pd.to_datetime(kw[k], errors="coerce").to_pydatetime()
            except Exception:
                del kw[k]
    return kw


# --- Path bootstrap
_REPO_ROOT = Path(__file__).resolve().parents[2]
if str(_REPO_ROOT) not in sys.path:
    sys.path.insert(0, str(_REPO_ROOT))

try:
    from app.utils.logger import log_error
except Exception:
    def log_error(e: Exception, context: str | None = None):
        try:
            print("[ghost_calc]", context or "", e)
        except Exception:
            pass

# ---------- Helpers ----------

def american_to_decimal(odds: int | float) -> float:
    o = float(odds)
    return 1.0 + (o / 100.0 if o > 0 else 100.0 / abs(o))


def decimal_to_american(dec: float) -> int:
    if dec <= 1.0:
        return -100
    return int(round((dec - 1.0) * 100)) if dec >= 2.0 else int(round(-100.0 / (dec - 1.0)))


@dataclass(frozen=True)
class Leg:
    game_id: str
    market: str
    side: str
    book: str
    odds: int
    p_win: float

    @property
    def dec(self) -> float:
        return american_to_decimal(self.odds)

    @property
    def label(self) -> str:
        g = self.game_id.split("-")[-1] if "-" in self.game_id else self.game_id
        mk = {"Moneyline": "ML", "ML": "ML"}.get(self.market, self.market)
        # Ensure odds render as integer with sign
        return f"{g}:{mk} {self.side} {int(self.odds):+d}"


def combo_prob(legs: List[Leg]) -> float:
    p = 1.0
    for lg in legs:
        p *= max(0.0, min(1.0, float(lg.p_win)))
    return p


def combo_decimal(legs: List[Leg]) -> float:
    d = 1.0
    for lg in legs:
        d *= lg.dec
    return d


def ev_for_one_unit_stake(legs: List[Leg]) -> Tuple[float, float, float]:
    """Returns (EV, ROI, dec_odds) for a 1-unit stake."""
    if not legs:
        return (0.0, 0.0, 0.0)
    p, d = combo_prob(legs), combo_decimal(legs)
    ev = p * (d - 1.0) - (1.0 - p)
    return (ev, ev, d)


def kelly_fraction(legs: List[Leg]) -> float:
    p, b = combo_prob(legs), combo_decimal(legs) - 1.0
    q = 1.0 - p
    if b <= 0:
        return 0.0
    return max(0.0, (b * p - q) / b)


# ---------- Ghost optimizer ----------

def ghost_optimize(legs: List[Leg]) -> Tuple[List[Leg], Dict[str, Any]]:
    """Greedy drop: iteratively remove a single leg if it increases EV."""
    current = list(legs)
    ev_now, _, _ = ev_for_one_unit_stake(current)
    drops = []
    while len(current) >= 2:
        best_idx, best_ev = None, ev_now
        for i in range(len(current)):
            candidate = current[:i] + current[i + 1 :]
            ev_c, _, _ = ev_for_one_unit_stake(candidate)
            if ev_c > best_ev + 1e-12:
                best_ev, best_idx = ev_c, i
        if best_idx is not None:
            removed = current.pop(best_idx)
            drops.append({"removed": removed.label, "new_ev": best_ev})
            ev_now = best_ev
        else:
            break
    return current, {"drops": drops, "final_ev": ev_now}


# ---------- UI ----------
st.title(" Ghost Parlay Calculator")

ROOT = Path(os.getenv("EDGE_FINDER_ROOT", "")) if os.getenv("EDGE_FINDER_ROOT") else _REPO_ROOT
EXPORT = ROOT / "exports"
EDGES, CANDS, BETLOG = EXPORT / "edges.csv", EXPORT / "hedge_candidates.csv", EXPORT / "bets_log.csv"

with st.expander("Paths", expanded=False):
    st.code(f"ROOT={ROOT}\nEDGES={EDGES}\nBETLOG={BETLOG}")


@st.cache_data
def load_edges(path: Path) -> pd.DataFrame:
    if not path.exists() or path.stat().st_size == 0:
        return pd.DataFrame()
    df = pd.read_csv(path)
    df.columns = [c.lower().strip() for c in df.columns]
    if "p_win" in df:
        df["p_win"] = pd.to_numeric(df["p_win"], errors="coerce")
    if "odds" in df:
        df["odds"] = pd.to_numeric(df["odds"], errors="coerce").fillna(0).astype(int)
    return df


edges_df = load_edges(EDGES)

if edges_df.empty:
    st.warning("No edges found. Populate exports/edges.csv.")
    st.stop()

# Sidebar
with st.sidebar:
    st.header("Build Controls")
    max_legs = st.slider("Max legs", 2, 8, 4)
    min_p = st.slider("Min leg win prob", 0.40, 0.80, 0.50, 0.01)
    min_abs_odds = st.number_input("Min |odds|", value=100)
    enforce_distinct = st.checkbox("Distinct games only", True)
    top_k_pool = st.number_input("Top-K legs", 10, 5000, 200, 10)
    limit_combos = st.number_input("Cap combos (0=no cap)", 0, 200000, 5000, 500)

    st.divider()
    st.header("Ranking & Filters")
    min_roi_pct = st.number_input("Min ROI (%)", value=0.0, step=0.1, format="%.1f")
    min_kelly = st.number_input("Min Kelly", value=0.0, step=0.01)
    show_n = st.number_input("Show top N", 5, 2000, 100, 5)

# Build + optimize
def __ensure_book_kw(d):
    dd = dict(d)
    dd.setdefault("book", "unknown")
    return dd

all_legs = [Leg(**__ensure_book_kw(_row_to_leg_kwargs(r))) for r in edges_df.to_dict("records")]# (enforce_distinct and top_k_pool can be applied here in the future)
pool = [lg for lg in all_legs if lg.p_win >= min_p and abs(lg.odds) >= min_abs_odds]

run_build = st.button("Generate Ghost Parlays", type="primary")
results_rows = []

if run_build:
    with st.spinner("Building combos..."):
        combos = []
        for r in range(2, max_legs + 1):
            combos.extend(combinations(pool, r))
            if limit_combos and len(combos) >= limit_combos:
                break

        for combo in combos:
            ev0, roi0, d0 = ev_for_one_unit_stake(combo)
            opt_legs, details = ghost_optimize(combo)
            ev1, roi1, d1 = ev_for_one_unit_stake(opt_legs)
            kf = kelly_fraction(opt_legs)
            if roi1 * 100 >= min_roi_pct and kf >= min_kelly:
                results_rows.append({
                    "legs": " + ".join(l.label for l in opt_legs),
                    "n_legs": len(opt_legs),
                    "american": decimal_to_american(d1),
                    "decimal": round(d1, 4),
                    "p_combo": round(combo_prob(opt_legs), 6),
                    "ev_unit": round(ev1, 6),
                    "roi_%": round(roi1 * 100, 3),
                    "kelly": round(kf, 3),
                    "legs_json": json.dumps([l.__dict__ for l in opt_legs]),
                })

# Prefer the latest built results from session so the UI survives reruns
res_df = st.session_state.get("ghost_res_df")

if isinstance(res_df, pd.DataFrame) and not res_df.empty:
    st.subheader("Top Ghosted Parlays")
    st.dataframe(res_df.head(show_n), use_container_width=True)

    with st.expander("Select parlays to add to Bet Log", expanded=False):
        # stable mapping & widget keys
        options = {f"{i}: {r['n_legs']} legs @ {r['american']} ROI%={r['roi_%']:.2f}": i
                   for i, r in res_df.iterrows()}
        st.session_state["ghost_sel"] = st.multiselect(
            "Choose",
            list(options.keys()),
            default=st.session_state.get("ghost_sel", []),
            key="ghost_multiselect",
        )
        stake = st.number_input("Stake", 0.0, step=0.5, key="ghost_stake")
        book = st.text_input("Book", "", key="ghost_book")
        notes = st.text_input("Notes", "Ghost parlay", key="ghost_notes")

        # nice label (fix mojibake) and safe write
        if st.button("âžœ Add selected to Bet Log", disabled=not st.session_state["ghost_sel"], key="ghost_add_btn"):
            try:
                take = res_df.loc[[options[s] for s in st.session_state["ghost_sel"]]]

                # ensure folder exists
                BETLOG.parent.mkdir(parents=True, exist_ok=True)

                # load existing log (if any)
                try:
                    existing = pd.read_csv(BETLOG)
                except Exception:
                    existing = pd.DataFrame()

                new_rows = []
                for _, r in take.iterrows():
                    new_rows.append({
                        "ts": datetime.utcnow().isoformat(),
                        "game_id": "PARLAY",
                        "market": "GHOST",
                        "ref": r["legs"],
                        "side": "-",
                        "line": 0,
                        "odds": int(r["american"]),
                        "p_win": r["p_combo"],
                        "ev": r["ev_unit"],
                        "stake": stake,
                        "book": book,
                        "notes": notes,
                        "legs_json": r["legs_json"],
                    })

                pd.concat([existing, pd.DataFrame(new_rows)], ignore_index=True).to_csv(BETLOG, index=False)
                st.success(f"Appended {len(new_rows)} to {BETLOG}")
                # optional: immediately show what was appended
                st.dataframe(pd.DataFrame(new_rows), use_container_width=True)
            except Exception as e:
                st.error(str(e))
else:
    st.info("Build some parlays first with **Generate Ghost Parlays**.")









