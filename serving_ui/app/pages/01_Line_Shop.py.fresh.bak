# 01_Line_Shop.py — full drop-in
from pathlib import Path
import pandas as pd
import numpy as np
import streamlit as st


# ==== Workflow controls: update lines / scan edges / auto-refresh ====
import sys, subprocess, time
from datetime import datetime
from pathlib import Path

def _repo_root() -> Path:
    env = os.environ.get("EDGE_FINDER_ROOT")
    if env and Path(env).exists():
        return Path(env)
    try:
        here = Path(__file__).resolve()
    except Exception:
        here = Path.cwd()
    for up in [here] + list(here.parents):
        if (up / "exports").exists():
            return up
    return Path.cwd()

REPO = _repo_root()
EXPORTS = REPO / "exports"

def _find_script(cands: list[str]) -> Path | None:
    for rel in cands:
        p = REPO / rel
        if p.exists():
            return p
    return None

# odds puller → updates exports/lines_live.csv
ODDS_PULLER = _find_script([
    "tools/pull_lines.py",
    "tools/pull_odds.py",
    "serving_ui/pull_lines.py",
    "serving/pull_lines.py",
])

# edge scanner → updates exports/edges.csv
EDGE_SCANNER = _find_script([
    "tools/scan_edges.py",
    "serving_ui/scan_edges.py",
    "serving/scan_edges.py",
])

def _run(label: str, script: Path) -> tuple[int,str,str]:
    try:
        proc = subprocess.run([sys.executable, str(script)],
                              cwd=str(script.parent),
                              capture_output=True, text=True, timeout=300)
        return proc.returncode, proc.stdout, proc.stderr
    except Exception as e:
        return -1, "", f"{label} error: {e}"

with st.expander("⚙️ Workflow controls", expanded=False):
    colA, colB, colC, colD = st.columns([1,1,1,2])

    with colA:
        upd_lines = st.button("Update Lines", disabled=not bool(ODDS_PULLER))
        if not ODDS_PULLER:
            st.caption("No odds puller found (looked for tools/ pull_*).")

    with colB:
        scan_edges = st.button("Scan Edges", disabled=not bool(EDGE_SCANNER))
        if not EDGE_SCANNER:
            st.caption("No edge scanner found (expected tools/scan_edges.py).")

    with colC:
        both = st.button("Update Lines + Edges",
                         disabled=not (ODDS_PULLER and EDGE_SCANNER))

    with colD:
        auto = st.toggle("Auto-reload", value=False, help="Reload this page on a timer (client-side).")
        every = st.number_input("Seconds", 5, 3600, 30, 5)
        if auto:
            st.markdown(
                f"<script>setTimeout(() => window.location.reload(), {int(every)*1000});</script>",
                unsafe_allow_html=True
            )

    logs = st.empty()

    def _after_run():
        try:
            st.cache_data.clear()
        except Exception:
            pass
        st.rerun()

    if 'upd_lines' in locals() and upd_lines and ODDS_PULLER:
        rc, out, err = _run("Odds pull", ODDS_PULLER)
        logs.code((out or "").strip() + ("\n" + err if err else ""), language="bash")
        st.success(f"Odds puller finished (rc={rc}). Wrote {EXPORTS/'lines_live.csv'} at {datetime.now():%H:%M:%S}.")
        _after_run()

    if 'scan_edges' in locals() and scan_edges and EDGE_SCANNER:
        rc, out, err = _run("Edge scan", EDGE_SCANNER)
        logs.code((out or "").strip() + ("\n" + err if err else ""), language="bash")
        st.success(f"Edge scanner finished (rc={rc}). Wrote {EXPORTS/'edges.csv'} at {datetime.now():%H:%M:%S}.")
        _after_run()

    if 'both' in locals() and both and ODDS_PULLER and EDGE_SCANNER:
        rc1, out1, err1 = _run("Odds pull", ODDS_PULLER)
        rc2, out2, err2 = _run("Edge scan", EDGE_SCANNER)
        logs.code("\\n\\n".join([(out1 or "") + ("\\n" + err1 if err1 else ""),
                               (out2 or "") + ("\\n" + err2 if err2 else "")]).strip(),
                  language="bash")
        st.success(f"Updated lines and edges (rcs={rc1},{rc2}).")
        _after_run()
# ==== end workflow controls ====

st.set_page_config(page_title="Edge Finder — Line Shop", layout="wide")
st.title("Line Shop")

# ----- Paths (repo root, not serving_ui) -----
REPO  = Path(__file__).resolve().parents[3]
CSV   = REPO / "exports" / "lines_live.csv"       # odds snapshot
MODEL = REPO / "exports" / "model_probs.csv"      # optional: game_id,market,selection,prob (0..1)

# ----- Helpers -----
def american_to_decimal(odds):
    try: o = float(odds)
    except: return np.nan
    if o > 0: return 1.0 + (o / 100.0)
    if o < 0: return 1.0 + (100.0 / abs(o))
    return np.nan

def implied_prob(odds):
    try: o = float(odds)
    except: return np.nan
    if o > 0: return 100.0 / (o + 100.0)
    if o < 0: return abs(o) / (abs(o) + 100.0)
    return np.nan

def ev_percent(p, dec):
    if pd.isna(p) or pd.isna(dec) or dec <= 1.0: return np.nan
    b = dec - 1.0
    return 100.0 * (p*b - (1.0 - p))

def ev_dollars(p, dec, stake):
    if pd.isna(p) or pd.isna(dec) or dec <= 1.0: return np.nan
    b = dec - 1.0
    return stake * (p*b - (1.0 - p))

def kelly_fraction(p, dec):
    if pd.isna(p) or pd.isna(dec) or dec <= 1.0: return 0.0
    b = dec - 1.0
    f = (p*b - (1.0 - p)) / b
    return max(0.0, float(f))

def best_rows(df):
    d = df.copy()
    d["Decimal"] = d["American"].apply(american_to_decimal)
    # rank by best decimal (highest payout) per selection
    d["_rank"] = d.groupby(["game_id","market","selection"])["Decimal"].rank(ascending=False, method="first")
    return d[d["_rank"] == 1.0].drop(columns=["_rank"])

def load_model_probs():
    if not MODEL.exists() or MODEL.stat().st_size == 0:
        return None
    mp = pd.read_csv(MODEL)
    mp.columns = [c.lower().strip() for c in mp.columns]
    need = {"game_id","market","selection","prob"}
    if not need.issubset(mp.columns):
        st.warning(f"model_probs.csv missing {sorted(list(need - set(mp.columns)))}; EV/Kelly disabled.")
        return None
    mp["prob"] = pd.to_numeric(mp["prob"], errors="coerce").clip(0,1)
    return mp.dropna(subset=["prob"])

def read_lines():
    if not CSV.exists() or CSV.stat().st_size == 0:
        return pd.DataFrame()
    df = pd.read_csv(CSV)
    cols = ["pulled_ts","game_id","commence_time","home","away","book","market","selection","price_american","point"]
    missing = [c for c in cols if c not in df.columns]
    if missing:
        st.error(f"lines_live.csv missing columns: {missing}")
        return pd.DataFrame()
    df = df.rename(columns={"price_american":"American", "point":"Line/Point"})
    df["American"] = pd.to_numeric(df["American"], errors="coerce")
    df["commence_time"] = pd.to_datetime(df["commence_time"], errors="coerce")
    return df

# ----- Sidebar controls -----
st.sidebar.header("Filters")
team_q    = st.sidebar.text_input("Team search (home/away contains)")
market    = st.sidebar.selectbox("Market", ["all","h2h","spreads","totals"], index=0)
min_books = st.sidebar.number_input("Min # of books per selection", 1, 20, 1, 1)

st.sidebar.header("EV & Kelly")
stake_display = st.sidebar.number_input("EV display stake ($)", 1, 10000, 100, 25)
show_pos_ev   = st.sidebar.toggle("Show only +EV (needs model_probs)", value=False)
min_ev_pct    = st.sidebar.number_input("Min EV %", value=0.0, step=0.5)

bankroll      = st.sidebar.number_input("Bankroll ($)", 0, 10_000_000, 1000, 50)
kelly_cap     = st.sidebar.number_input("Kelly fraction cap (0..1)", 0.0, 1.0, 0.25, 0.05)

# ----- Load data -----
df = read_lines()
if df.empty:
    st.warning("No live odds found. Populate exports/lines_live.csv (run your odds pull).")
    st.stop()

# Basic filters
if team_q:
    s = team_q.strip().lower()
    df = df[df["home"].str.lower().str.contains(s) | df["away"].str.lower().str.contains(s)]
if market != "all":
    df = df[df["market"] == market]

# Books filter
books = sorted(df["book"].dropna().unique().tolist())
chosen_books = st.sidebar.multiselect("Books", books, default=books)
if chosen_books:
    df = df[df["book"].isin(chosen_books)]

# Count #books per selection
counts = df.groupby(["game_id","market","selection"])["book"].nunique().rename("#Books")
df = df.merge(counts, on=["game_id","market","selection"], how="left")
df = df[df["#Books"] >= int(min_books)]

# Merge model probabilities (optional)
mp = load_model_probs()
if mp is not None:
    df = df.merge(mp, on=["game_id","market","selection"], how="left")
    df.rename(columns={"prob":"Model Prob"}, inplace=True)

# Common enrichment
df["Decimal"] = df["American"].apply(american_to_decimal)
df["Impl. Prob (Odds)"] = df["American"].apply(implied_prob)

if "Model Prob" in df.columns:
    df["EV %"]      = df.apply(lambda r: ev_percent(r["Model Prob"], r["Decimal"]), axis=1)
    df[f"EV @ ${stake_display}"] = df.apply(lambda r: ev_dollars(r.get("Model Prob"), r["Decimal"], stake_display), axis=1)
    df["Kelly f"]   = df.apply(lambda r: kelly_fraction(r.get("Model Prob"), r["Decimal"]), axis=1)
    df["Kelly stake ($)"] = (df["Kelly f"].clip(lower=0) * kelly_cap * bankroll).round(2)
else:
    df["EV %"] = df[f"EV @ ${stake_display}"] = df["Kelly f"] = df["Kelly stake ($)"] = np.nan

# Optional EV filter
if show_pos_ev and "EV %" in df.columns:
    df = df[df["EV %"].fillna(-999) >= float(min_ev_pct)]

# Column order for display
base_cols = ["commence_time","home","away","market","selection","book","American","Line/Point","Decimal","Impl. Prob (Odds)","#Books"]
ev_cols   = ["Model Prob","EV %",f"EV @ ${stake_display}","Kelly f","Kelly stake ($)"] if "Model Prob" in df.columns else []
show_cols = [c for c in base_cols + ev_cols if c in df.columns]

# Tabs
tab_best, tab_all = st.tabs(["Quick Odds Shop (Best Price)", "All Quotes"])

with tab_best:
    best = best_rows(df)
    st.caption("Shows the single best price for each unique (game_id, market, selection).")
    st.dataframe(best[show_cols], use_container_width=True, hide_index=True)

    # Simple selection -> Bet Slip
    st.subheader("Pick rows to add to Bet Slip")
    # Provide an ID for selection
    best = best.assign(_id=(best["game_id"] + "|" + best["market"] + "|" + best["selection"] + "|" + best["book"].astype(str)))
    choices = best["_id"].tolist()
    labels  = (best["home"] + " @ " + best["away"] + " • " + best["market"] + " • " + best["selection"] + " • " + best["book"]).tolist()
    pick_map = dict(zip(labels, choices))
    picked = st.multiselect("Choose one or more", labels, key="ls_picklist")

    if "bet_slip" not in st.session_state:
        st.session_state["bet_slip"] = []

    if st.button("➕ Add selected to Bet Slip"):
        new_ids = {pick_map[lbl] for lbl in picked}
        add = best[best["_id"].isin(new_ids)]
        to_add = add.assign(stake=np.where(pd.notna(add.get("Kelly stake ($)")), add["Kelly stake ($)"], 0.0))
        st.session_state["bet_slip"].extend(to_add.to_dict("records"))
        st.success(f"Added {len(to_add)} selections to Bet Slip")

with tab_all:
    st.dataframe(df[show_cols], use_container_width=True, hide_index=True)

st.markdown("---")
st.header("🧾 Bet Slip")

# Render bet slip
slip = pd.DataFrame(st.session_state.get("bet_slip", []))
if slip.empty:
    st.info("Your Bet Slip is empty. Use the Best tab to select rows and click **Add selected to Bet Slip**.")
else:
    display_cols = [c for c in ["home","away","market","selection","book","American","Decimal","Model Prob","EV %","Kelly f","Kelly stake ($)","stake"] if c in slip.columns]
    st.dataframe(slip[display_cols], use_container_width=True, hide_index=True)
    # Total suggested stake
    if "stake" in slip.columns:
        st.write(f"**Total stake:** ${float(pd.to_numeric(slip['stake'], errors='coerce').fillna(0).sum()):,.2f}")
    # Clear slip
    if st.button("🗑️ Clear Bet Slip"):
        st.session_state["bet_slip"] = []
        st.experimental_rerun()