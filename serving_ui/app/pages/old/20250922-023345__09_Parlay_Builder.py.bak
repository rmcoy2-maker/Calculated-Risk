# ---- PATH SHIM (auto-added) ----
import sys, pathlib
_APP_DIR = pathlib.Path(__file__).resolve().parents[1]  # ...\serving_ui\app
_PARENT  = _APP_DIR.parent                              # ...\serving_ui
if str(_PARENT) not in sys.path:
    sys.path.insert(0, str(_PARENT))
# ---- END PATH SHIM ----
# --- path bootstrap (make top-level 'app' importable) ---
import sys
from pathlib import Path
PROJ_ROOT = Path(__file__).resolve().parents[3]
if str(PROJ_ROOT) not in sys.path:
    sys.path.insert(0, str(PROJ_ROOT))
# ---------------------------------------
try:
    from app.lib.metrics import weekly_roi_closed as weekly_roi
except ModuleNotFoundError:
    from lib.metrics import weekly_roi_closed as weekly_roi
# -*- coding: utf-8 -*-
# 09_Parlay_Builder.py — CLEANED + Suggestions
# - Keeps your original Manual Build, Picker, Custom Leg, Correlation Guard, Refresh edges
# - Adds a robust ?? "Computer Suggested Parlays" panel at the end
# - No `from __future__` inside the file (fixes the SyntaxError you hit)

import sys, json, uuid, heapq, itertools, os, datetime
from pathlib import Path
import pandas as pd
import numpy as np
import streamlit as st
from datetime import date

# ----------------------------- setup / paths -----------------------------
ROOT = Path(__file__).resolve().parents[2]          # ...\serving_ui
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))
REPO = ROOT.parents[1]                               # ...\edge-finder
EXPORTS = ROOT / "exports"
EXPORTS.mkdir(parents=True, exist_ok=True)

def _pick_latest_edges():
    # Hard-lock to serving_ui/exports/edges.csv
    return EXPORTS / "edges.csv"

with st.expander("Edges source (debug)", expanded=False):
    try:
        src = _pick_latest_edges()
        ts = datetime.datetime.fromtimestamp(os.path.getmtime(src))
        st.write(f"Using: `{src}`")
        st.write(f"Last modified: {ts}")
    except Exception as e:
        st.error(f"Could not determine edges source: {e}")

# Files
PARLAYS_CSV = EXPORTS / "parlays.csv"
BETS_LOG_CSV = EXPORTS / "bets_log.csv"
PARLAY_HEADER = ["ts","market","odds","p_win","ev","stake","status","result","pnl","tag","legs_json","parlay_id","notes"]
BETLOG_HEADER = ["ts","market","ref","side","line","odds","p_win","ev","stake","status","result","pnl","tag","legs_json","bet_id","notes"]

# ----------------------------- imports from lib -----------------------------
from app.lib.csv_utils import append_dict_row, utc_ts
from app.lib.correlation import check_correlation

# ----------------------------- helpers -----------------------------
def _normalize_corr_result(res):
    if isinstance(res, tuple) and len(res) >= 2:
        ok, details = res[0], res[1]
        return bool(ok), (details if isinstance(details, dict) else {"details": details})
    if isinstance(res, bool):
        return res, {}
    if res is None:
        return True, {}
    return True, {"details": res}

def american_to_decimal(odds: int) -> float:
    odds = int(odds)
    return 1 + (odds/100.0 if odds > 0 else 100.0/abs(odds))

def implied_prob_from_american(am: float) -> float:
    am = float(am)
    return 100.0 / (am + 100.0) if am >= 0 else abs(am) / (abs(am) + 100.0)

def prob_or_implied(lg) -> float:
    try:
        p = float(lg.get("p_win", float("nan")))
    except Exception:
        p = float("nan")
    if not (0.0 < p < 1.0):
        p = implied_prob_from_american(lg["odds"])
    return max(0.0, min(1.0, p))

def parlay_stats(legs: list[dict]):
    parlay_dec, parlay_p = 1.0, 1.0
    for lg in legs:
        parlay_dec *= american_to_decimal(lg["odds"])
        parlay_p   *= prob_or_implied(lg)
    if parlay_dec <= 1.0000001:
        parlay_am = -1000000
    else:
        parlay_am = int(round((parlay_dec-1)*100)) if parlay_dec >= 2 else int(round(-100/(parlay_dec-1)))
    ev = (parlay_dec * parlay_p) - 1
    return parlay_dec, parlay_am, parlay_p, ev

def kelly_fraction(p: float, american_odds: int, aggressiveness: float = 1.0) -> float:
    try:
        p = float(p)
        b = american_to_decimal(int(american_odds)) - 1.0
        q = 1.0 - p
        if b <= 0 or not (0.0 < p < 1.0):
            return 0.0
        f = (b * p - q) / b
        f = max(0.0, min(1.0, f))
        return float(aggressiveness) * f
    except Exception:
        return 0.0

def read_current_bankroll(default: float = 0.0) -> float:
    try:
        p = EXPORTS / "bankroll.csv"
        if not p.exists():
            return float(default)
        _df = pd.read_csv(p, encoding="utf-8-sig")
        if "bankroll" in _df.columns and not _df.empty:
            return float(_df["bankroll"].iloc[-1])
    except Exception:
        pass
    return float(default)

def log_parlay(legs, odds, p_win, ev, stake=None, tag="manual", notes=""):
    row = {"ts": utc_ts(),"market":"parlay","odds":odds,"p_win":p_win,"ev":ev,"stake":stake,"status":"open",
           "result":None,"pnl":None,"tag":tag,"legs_json":json.dumps(legs),"parlay_id":uuid.uuid4().hex[:12],"notes":notes}
    append_dict_row(PARLAYS_CSV, row, PARLAY_HEADER)
    return row

def log_bet(legs, odds, p_win, ev, stake=None, tag="manual", notes=""):
    row = {"ts": utc_ts(),"market":"parlay","ref":None,"side":None,"line":None,"odds":odds,"p_win":p_win,"ev":ev,"stake":stake,
           "status":"open","result":None,"pnl":None,"tag":tag,"legs_json":json.dumps(legs),"bet_id":uuid.uuid4().hex[:12],"notes":notes}
    append_dict_row(BETS_LOG_CSV, row, BETLOG_HEADER)
    return row

# ----------------------------- UI setup -----------------------------
st.set_page_config(page_title="Parlay Builder", layout="wide")
st.title("Parlay Builder")
if "picked_legs" not in st.session_state:
    st.session_state["picked_legs"] = []

# ----------------------------- manual build -----------------------------
with st.expander("Manual Build", expanded=True):
    st.write("Pick legs manually, edit them, and log parlays.")
    legs = st.session_state["picked_legs"]
    st.dataframe(pd.DataFrame(legs), use_container_width=True, hide_index=True)

    if legs:
        dec, am, p, ev = parlay_stats(legs)
        c1, c2, c3 = st.columns(3)
        c1.metric("Odds", f"{am:+}")
        c2.metric("Win prob", f"{p:.2%}")
        c3.metric("EV", f"{ev:+.3f}")

        bk_default = read_current_bankroll(0.0)
        k1, k2, k3 = st.columns([1.2,1,1])
        with k1: bankroll_val = st.number_input("Bankroll (from ledger)", min_value=0.0, step=10.0, value=float(bk_default))
        with k2: kelly_scale = st.selectbox("Kelly scale", ["1.00 (Full)","0.50 (Half)","0.25 (Quarter)"], index=1)
        with k3: k_mult = {"1.00 (Full)":1.00,"0.50 (Half)":0.50,"0.25 (Quarter)":0.25}[kelly_scale]
        k_frac = kelly_fraction(p, am, k_mult)
        k_stake = round(bankroll_val * k_frac, 2) if bankroll_val and k_frac else 0.0

        s1, s2 = st.columns([1,2])
        with s1: st.metric("Kelly fraction", f"{k_frac:.2%}")
        with s2: stake_input = st.number_input("Stake (defaults to Kelly recommendation)", min_value=0.0, step=1.0, value=float(k_stake))
        notes = st.text_input("Notes", key="manual_notes")

        def _bucket_market(m: str) -> str:
            s = str(m or "").lower()
            if "moneyline" in s or s in ("ml","h2h"): return "Moneyline"
            if "spread" in s: return "Spread"
            if "total" in s: return "Total (O/U)"
            if "prop" in s: return "Props"
            return "Other"

        with st.expander("Summary", expanded=True):
            _df = pd.DataFrame(legs)
            if not _df.empty:
                _df["bucket"] = _df["market"].apply(_bucket_market)
                type_counts = _df["bucket"].value_counts().rename_axis("type").reset_index(name="count")
                book_counts = (_df["book"].fillna("—").value_counts().rename_axis("book").reset_index(name="count")) if "book" in _df.columns else pd.DataFrame({"book": [], "count": []})
                sA, sB, sC = st.columns(3)
                with sA: st.caption("Legs by type"); st.dataframe(type_counts, use_container_width=True, hide_index=True)
                with sB: st.caption("Legs by book"); st.dataframe(book_counts, use_container_width=True, hide_index=True)
                with sC:
                    st.caption("Parlay metrics")
                    st.write(f"**American odds:** {am:+}")
                    st.write(f"**Win prob:** {p:.2%}")
                    st.write(f"**EV (per $1):** {ev:+.3f}")
                    st.write(f"**Kelly stake @ {kelly_scale}:** ${k_stake:,.2f}")
            else:
                st.caption("No legs selected yet.")

        a, b = st.columns(2)
        with a:
            if st.button("Log Manual Parlay"):
                try:
                    row = log_parlay(legs, am, p, ev, stake=stake_input, tag="manual", notes=notes)
                    log_bet(legs, am, p, ev, stake=stake_input, tag="manual", notes=notes)
                    st.success(f"Manual parlay logged (ID: {row['parlay_id']})")
                except Exception as e:
                    st.error(f"Failed to log manual parlay: {e}")
        with b:
            if st.button("??? Clear Legs"):
                st.session_state["picked_legs"] = []
                st.rerun()

# ----------------------------- picker / multi-add -----------------------------
with st.expander("Pick legs (edges.csv) + Build from market_lines", expanded=False):

    def _to_int_odds(x):
        try:
            s = str(x).strip().replace("+","")
            return int(round(float(s)))
        except Exception:
            return None

    def _build_edges_from_lines(df_src: pd.DataFrame) -> pd.DataFrame:
        d = df_src.copy()
        d.columns = [c.lower() for c in d.columns]
        ren = {"sportsbook":"book","book_name":"book","bookmaker":"book","site":"book",
               "american":"odds","price":"odds","bet_type":"market","market_type":"market","wager_type":"market",
               "selection":"side","team":"side","total":"line","points":"line","threshnew":"line",
               "prob":"p_win","probability":"p_win","implied_prob":"p_win","note":"ref","id":"ref"}
        d.rename(columns={k:v for k,v in ren.items() if k in d.columns}, inplace=True)
        for col in ["game_id","book","market","side","player","line","odds","p_win","ref","home_team","away_team","start_time","outcome"]:
            if col not in d.columns: d[col] = None

        def mk_game_id(r):
            if pd.notna(r.get("game_id")) and str(r.get("game_id")).strip():
                return str(r["game_id"])
            ht, at = r.get("home_team"), r.get("away_team")
            dt = str(r.get("start_time") or "")
            if pd.notna(ht) and pd.notna(at):
                return f"{dt[:10]}-{str(at)[:3]}@{str(ht)[:3]}".replace(" ","")
            return None

        rows = []
        ml_mask = d["market"].astype(str).str.contains(r"\b(ml|moneyline|h2h)\b", case=False, na=False)
        for _, r in d[ml_mask].iterrows():
            rows.append({"game_id": mk_game_id(r), "market":"Moneyline", "side":r.get("side"),
                         "line":None, "book":r.get("book"), "odds":_to_int_odds(r.get("odds")),
                         "p_win":r.get("p_win"), "ref":r.get("ref")})
        sp = d[d["market"].astype(str).str.contains("spread", case=False, na=False)]
        for _, r in sp.iterrows():
            rows.append({"game_id": mk_game_id(r), "market":"Spread", "side":r.get("side"),
                         "line":r.get("line"), "book":r.get("book"), "odds":_to_int_odds(r.get("odds")),
                         "p_win":r.get("p_win"), "ref":r.get("ref")})
        tot = d[d["market"].astype(str).str.contains("total", case=False, na=False)]
        for _, r in tot.iterrows():
            ou = (r.get("outcome") or r.get("side") or "").strip().title()
            if ou not in ("Over","Under"):
                s = str(r.get("side") or "")
                ou = "Over" if "o" in s.lower() else ("Under" if "u" in s.lower() else "Over")
            rows.append({"game_id": mk_game_id(r), "market":"Total", "side":ou,
                         "line":r.get("line"), "book":r.get("book"), "odds":_to_int_odds(r.get("odds")),
                         "p_win":r.get("p_win"), "ref":r.get("ref")})
        has_player = "player" in d.columns
        prop_mask = d["market"].astype(str).str.contains("prop", case=False, na=False)
        if has_player:
            prop_mask = prop_mask | d["player"].notna()
        pr = d[prop_mask]
        for _, r in pr.iterrows():
            m = str(r.get("market") or "")
            ptype = m.split(":", 1)[-1].strip() if ":" in m.lower() else (m if "prop" in m.lower() else "Prop")
            ou = (r.get("outcome") or r.get("side") or "").strip().title()
            if ou not in ("Over", "Under"): ou = "Over"
            side = f"{ou} {str(r.get('player') or r.get('side') or '').strip()}".strip()
            rows.append({"game_id": mk_game_id(r), "market": f"Prop: {ptype}", "side": side,
                         "line": r.get("line"), "book": r.get("book"),
                         "odds": _to_int_odds(r.get("odds")), "p_win": r.get("p_win"), "ref": r.get("ref")})
        out = pd.DataFrame(rows, columns=["game_id","market","side","line","book","odds","p_win","ref"])
        return out[out["odds"].notna()].reset_index(drop=True)

    # ---- Load edges ----
    edges_path = ROOT / "exports" / "edges.csv"
    lines_2025 = EXPORTS / "market_lines_2025.csv"
    lines_any  = EXPORTS / "market_lines.csv"

    edges_df = None
    if edges_path.exists():
        try:
            edges_df = pd.read_csv(edges_path)
        except Exception:
            edges_df = None
    if edges_df is None and (lines_2025.exists() or lines_any.exists()):
        try:
            src = pd.read_csv(lines_2025 if lines_2025.exists() else lines_any)
            edges_df = _build_edges_from_lines(src)
        except Exception as e:
            st.error(f"Failed to build edges from market_lines: {e}")

    if edges_df is None or edges_df.empty:
        st.info("No edges found yet. Drop an 'exports/edges.csv' or 'exports/market_lines*.csv' to enable the picker.")
    else:
        show_cols = [c for c in ["game_id","market","side","line","book","odds","p_win","ref","start_time"] if c in edges_df.columns]
        disp = edges_df[show_cols].copy()
        if "p_win" in disp.columns:
            with np.errstate(invalid="ignore"):
                disp["p_win"] = pd.to_numeric(disp["p_win"], errors="coerce")
                disp["p_win"] = disp["p_win"].where((disp["p_win"]>0)&(disp["p_win"]<1), np.nan)
                disp["p_win"] = (disp["p_win"]*100).round(1)

        def _bucket_market(m: str) -> str:
            s = str(m or "").lower()
            if "moneyline" in s or s in ("ml","h2h"): return "Moneyline"
            if "spread" in s: return "Spread"
            if "total" in s: return "Total (O/U)"
            if "prop" in s: return "Props"
            return "Other"
        disp["bucket"] = disp["market"].apply(_bucket_market)

        # ---------- Quick filter row ----------
        r1, r2 = st.columns([1.2, 2])
        with r1:
            bucket_choice = st.radio("Bet type", ["All","Moneyline","Spread","Total (O/U)","Props"],
                                     horizontal=True, key="picker_bucket_choice")
        with r2:
            txt_search = st.text_input("Search team / player / text", key="picker_search",
                                       placehnewer="e.g., Dolphins, Over, Mahomes, -3.5")

        # ---------- More filters ----------
        with st.expander("More filters", expanded=False):
            types = ["Moneyline","Spread","Total (O/U)","Props","Other"]
            st.multiselect("Bet type(s)", options=types, default=types, key="picker_bucket_multi")
            if "odds" in disp.columns:
                all_odds = pd.to_numeric(disp["odds"], errors="coerce")
                o_min = int(all_odds.min(skipna=True)) if all_odds.notna().any() else -5000
                o_max = int(all_odds.max(skipna=True)) if all_odds.notna().any() else 10000
                o1, o2 = st.slider("American odds range", o_min, o_max, (o_min, o_max), step=5, key="picker_odds_range")
            else:
                o1, o2 = None, None
                st.caption("No 'odds' column found for odds range filter.")
            # Books
            books = sorted([b for b in disp.get("book", pd.Series(dtype=str)).dropna().unique().tolist() if str(b).strip()])
            st.multiselect("Sportsbook(s)", options=books, default=(books[:1] if books else []), key="picker_book_multi")
            # Default date cut = earliest date in data
            try:
                _dates = disp.apply(lambda r: pd.to_datetime(r.get("start_time"), errors="coerce"), axis=1).dt.date
                _dates = _dates[pd.notna(_dates)]
                default_cut = _dates.min() if len(_dates) else None
            except Exception:
                default_cut = None
            if 'picker_date_cut' not in st.session_state:
                st.session_state['picker_date_cut'] = (default_cut or date.today())
            st.date_input("Only include games on/after", value=st.session_state['picker_date_cut'], key="picker_date_cut")
            # Reset
            if st.button("Reset filters"):
                for k in ["picker_bucket_choice","picker_bucket_multi","picker_odds_range","picker_book_multi","picker_date_cut","picker_search"]:
                    if k in st.session_state: del st.session_state[k]
                st.rerun()

        # ---------- Apply filters ----------
        disp_filt = disp.copy()
        if bucket_choice != "All":
            disp_filt = disp_filt[disp_filt["bucket"] == bucket_choice]
        if "picker_bucket_multi" in st.session_state:
            disp_filt = disp_filt[disp_filt["bucket"].isin(st.session_state["picker_bucket_multi"])]
        if o1 is not None and o2 is not None and "odds" in disp_filt.columns:
            disp_filt = disp_filt[pd.to_numeric(disp_filt["odds"], errors="coerce").between(o1, o2)]
        if txt_search.strip():
            q = txt_search.strip().lower()
            cols = [c for c in ["game_id","market","side","line","book","ref"] if c in disp_filt.columns]
            if cols:
                mask = False
                for c in cols:
                    part = disp_filt[c].astype(str).str.lower().str.contains(q, na=False)
                    mask = (mask | part) if isinstance(mask, pd.Series) else part
                disp_filt = disp_filt[mask]
        # Book filter
        books_sel = st.session_state.get("picker_book_multi") or []
        if books_sel and "book" in disp_filt.columns:
            disp_filt = disp_filt[disp_filt["book"].isin(books_sel)]
        # Date cutoff
        dcut = st.session_state.get("picker_date_cut", date.today())
        # If no start_time, allow through (no date to compare)
        if "start_time" in disp_filt.columns:
            _d = pd.to_datetime(disp_filt["start_time"], errors="coerce").dt.date
            keep = (_d.isna()) | (_d >= dcut)
            disp_filt = disp_filt[keep]

        # ---------- Render + add ----------
        st.caption("Preview: edges available (filtered)")
        st.dataframe(disp_filt.head(200), use_container_width=True, hide_index=True)
        work = disp_filt.copy()
        work.insert(0, "add", False)
        edited = st.data_editor(work, use_container_width=True, hide_index=True, num_rows="dynamic", key="edges_editor")

        cA, cB, cC = st.columns([1,1,1])
        with cA:
            if st.button("? Add selected rows to Parlay"):
                add_rows = edited[edited["add"] == True]
                if add_rows.empty:
                    st.warning("No rows selected.")
                else:
                    def row_key(r):
                        return (str(r.get("game_id")), str(r.get("market")), str(r.get("side")),
                                str(r.get("line")), str(r.get("book")), str(r.get("odds")))
                    base = edges_df.copy()
                    base["__key__"] = base.apply(lambda r: row_key(r), axis=1)
                    to_add, added = [], 0
                    for _, r in add_rows.iterrows():
                        k = row_key(r)
                        match = base[base["__key__"] == k]
                        if not match.empty:
                            full = match.iloc[0].to_dict()
                            to_add.append({
                                "game_id": full.get("game_id"),
                                "market":  full.get("market"),
                                "side":    full.get("side"),
                                "line":    full.get("line"),
                                "book":    full.get("book"),
                                "odds":    int(str(full.get("odds")).replace("+","")) if pd.notna(full.get("odds")) else None,
                                "p_win":   full.get("p_win"),
                                "ref":     full.get("ref") if pd.notna(full.get("ref")) else uuid.uuid4().hex[:8],
                            })
                    cur = st.session_state.get("picked_legs", [])
                    exists = set((str(x.get("game_id")), str(x.get("market")), str(x.get("side")),
                                  str(x.get("line")), str(x.get("book")), str(x.get("odds"))) for x in cur)
                    for leg in to_add:
                        k = (str(leg.get("game_id")), str(leg.get("market")), str(leg.get("side")),
                             str(leg.get("line")), str(leg.get("book")), str(leg.get("odds")))
                        if k not in exists:
                            cur.append(leg); exists.add(k)
                    st.session_state["picked_legs"] = cur
                    st.success("Added selected legs.")
                    st.rerun()
        with cB:
            if st.button("Deduplicate current legs"):
                cur = st.session_state.get("picked_legs", [])
                seen, out = set(), []
                for leg in cur:
                    k = (str(leg.get("game_id")), str(leg.get("market")), str(leg.get("side")),
                         str(leg.get("line")), str(leg.get("book")), str(leg.get("odds")))
                    if k in seen: continue
                    seen.add(k); out.append(leg)
                st.session_state["picked_legs"] = out
                st.success(f"Deduped ? {len(out)} unique legs.")
                st.rerun()
        with cC:
            if st.button("Remove last leg"):
                cur = st.session_state.get("picked_legs", [])
                if cur:
                    cur.pop()
                    st.session_state["picked_legs"] = cur
                    st.rerun()

# ----------------------------- add a custom leg (interactive market switch) -----------------------------
with st.expander("Add a custom leg", expanded=False):
    mkt_choice = st.radio("Market", ["Moneyline","Spread","Total (O/U)","Prop"], horizontal=True, key="manual_mkt_choice")
    c_odds = st.number_input("American odds", step=5, value=+100)
    c_pwin = st.number_input("Win probability (0-1, optional)", step=0.01, min_value=0.0, max_value=1.0, value=0.0)
    c_ref  = st.text_input("Ref (optional)", value="")
    leg = None
    if mkt_choice == "Moneyline":
        side_team = st.text_input("Team / Side (e.g., Dolphins)", "")
        if st.button("? Add Moneyline leg"):
            leg = {"game_id": None, "market": "Moneyline", "side": side_team.strip(), "line": None, "book": None, "odds": int(c_odds), "p_win": (c_pwin if c_pwin > 0 else None), "ref": (c_ref.strip() or uuid.uuid4().hex[:8])}
    elif mkt_choice == "Spread":
        cs1, cs2 = st.columns([2,1])
        with cs1: side_team = st.text_input("Team / Side (e.g., Dolphins)", "")
        with cs2: line_txt = st.text_input("Spread (e.g., -3.5)", "")
        if st.button("? Add Spread leg"):
            leg = {"game_id": None, "market": "Spread", "side": side_team.strip(), "line": (line_txt if line_txt != "" else None), "book": None, "odds": int(c_odds), "p_win": (c_pwin if c_pwin > 0 else None), "ref": (c_ref.strip() or uuid.uuid4().hex[:8])}
    elif mkt_choice == "Total (O/U)":
        ct1, ct2, _ = st.columns([1,1,1])
        with ct1: ou = st.selectbox("O/U", ["Over","Under"], index=0)
        with ct2: total_line = st.number_input("Total line", step=0.5, value=45.5)
        if st.button("? Add Total (O/U) leg"):
            leg = {"game_id": None, "market": "Total", "side": ou, "line": total_line, "book": None, "odds": int(c_odds), "p_win": (c_pwin if c_pwin > 0 else None), "ref": (c_ref.strip() or uuid.uuid4().hex[:8])}
    else:
        cp1, cp2, cp3, cp4 = st.columns([1.4,1,1,1])
        with cp1: player = st.text_input("Player", "")
        with cp2: stat = st.selectbox("Stat", ["Points","Rebounds","Assists","Yards","Rush Yds","Rec Yds","Pass Yds","Other"], index=0)
        with cp3: ou = st.selectbox("O/U", ["Over","Under"], index=0)
        with cp4: prop_line = st.number_input("Line", step=0.5, value=20.5)
        if st.button("? Add Prop leg"):
            side_str = f"{ou} {player.strip()} {stat}".strip()
            leg = {"game_id": None, "market": f"Prop: {stat}", "side": side_str, "line": prop_line, "book": None, "odds": int(c_odds), "p_win": (c_pwin if c_pwin > 0 else None), "ref": (c_ref.strip() or uuid.uuid4().hex[:8])}
    if leg is not None:
        cur = st.session_state.get("picked_legs", [])
        cur.append(leg); st.session_state["picked_legs"] = cur
        st.success(f"{leg['market']} leg added."); st.rerun()

# ----------------------------- correlation guard -----------------------------
with st.expander("Validate current parlay (correlation guard)", expanded=False):
    legs = st.session_state.get("picked_legs", [])
    if not legs:
        st.info("No legs picked yet.")
    else:
        ok, msg = _normalize_corr_result(check_correlation(legs))
        if ok: st.success("? Correlation OK")
        else:  st.error(f"? Correlation guard blocked this parlay:\n\n{msg}")

# ----------------------------- reload edges -----------------------------
with st.expander("Refresh edges", expanded=False):
    c1, c2 = st.columns(2)
    with c1:
        if st.button("Reload edges.csv", key="reload_edges"):
            try:
                # Choose the one source you want. If you prefer to force the UI copy only, swap the next line:
                edges_path = _pick_latest_edges()
                # edges_path = ROOT / "exports" / "edges.csv"
                edges_df = pd.read_csv(edges_path)
                st.success(f"Reloaded edges from {edges_path.name} ({len(edges_df)} rows)")
                st.rerun()
            except Exception as e:
                st.error(f"Reload failed: {e}")
    with c2:
        if st.button("Rebuild from market_lines ? edges.csv", key="rebuild_from_lines"):
            try:
                lines_2025 = EXPORTS / "market_lines_2025.csv"
                lines_any  = EXPORTS / "market_lines.csv"
                src_path = lines_2025 if lines_2025.exists() else (lines_any if lines_any.exists() else None)
                if src_path is None:
                    st.warning("No market_lines*.csv found in exports/. Drop one in and try again.")
                else:
                    src = pd.read_csv(src_path)
                    new_edges = _build_edges_from_lines(src)
                    if new_edges is None or new_edges.empty:
                        st.warning("market_lines loaded but produced 0 rows.")
                    else:
                        outp = EXPORTS / "edges.csv"
                        new_edges.to_csv(outp, index=False)
                        st.success(f"Wrote {len(new_edges)} rows ? {outp.name}")
                        st.rerun()
            except Exception as e:
                st.error(f"Rebuild failed: {e}")

# ----------------------------- ?? Computer Suggested Parlays -----------------------------
st.subheader("Computer Suggested Parlays")

# Sanitizers
import re
from datetime import timedelta, timezone
UTC = timezone.utc
ALLOWED_MARKETS = {"ML", "MONEYLINE", "ATS", "SPREAD", "TOTAL", "OU", "O/U"}
TEAM_WHITELIST = {
    "NE","NYJ","GB","CHI","KC","BUF","DAL","PHI","MIN","NYG","MIA","BAL","PIT","CLE","CIN",
    "LAR","SF","SEA","ARI","LAC","LV","DEN","HOU","IND","JAX","TEN","TB","ATL","CAR","NO",
    "WSH","DET"
}
GAMEID_RE = re.compile(r"^(?:\d{4}-\d{2}-\d{2}-)?[A-Z]{2,4}@[A-Z]{2,4}$", re.I)

def looks_real_game_id(gid: str) -> bool:
    gid = (gid or "").strip().upper()
    if not GAMEID_RE.match(gid):
        return False
    # reject obviously far-off dates
    if len(gid) >= 10 and gid[0:4].isdigit():
        try:
            dt = datetime.datetime.fromisoformat(gid[:10]).replace(tzinfo=UTC)
            today = datetime.datetime.now(tz=UTC)
            if dt < today - datetime.timedelta(days=365*3) or dt > today + datetime.timedelta(days=365):
                return False
        except Exception:
            return False
    return True

def is_allowed_market(mkt: str) -> bool:
    return str(mkt).upper() in ALLOWED_MARKETS

def is_allowed_teams(gid: str) -> bool:
    gid = (gid or "").upper()
    m = re.search(r"([A-Z]{2,4})@([A-Z]{2,4})$", gid)
    if not m: return False
    away, home = m.groups()
    return away in TEAM_WHITELIST and home in TEAM_WHITELIST

def filter_edges(edges: pd.DataFrame) -> pd.DataFrame:
    if edges is None or edges.empty:
        return edges
    df = edges.copy()
    df["__gid"] = df.get("game_id", df.get("gid", "")).astype(str)
    df["__mkt"] = df.get("market","").astype(str)
    # drop prop-like noise
    prop_noise = df.get("ref", pd.Series([""] * len(df), index=df.index)).astype(str).str.contains(r"\b(WR\d|REC|RUSH|YDS|TD|PROP)\b", case=False, regex=True) | \
                 df.get("side","").astype(str).str.contains(r"\b(WR\d|REC|RUSH|YDS|TD|PROP)\b", case=False, regex=True)
    mask = (
        df["__gid"].map(looks_real_game_id) &
        df["__gid"].map(is_allowed_teams) &
        df["__mkt"].map(is_allowed_market) &
        (~prop_noise)
    )
    kept = df[mask].drop(columns=["__gid","__mkt"], errors="ignore")
    st.caption(f"Filtered edges: kept {len(kept)} / {len(df)} rows")
    return kept

# Load edges for suggestions
try:
    sugg_edges = pd.read_csv(EXPORTS / "edges.csv")
except Exception:
    sugg_edges = pd.DataFrame()

strict_mode = st.checkbox("Ignore suspected test/prop rows", value=True, key="sugg_strict")
if strict_mode and not sugg_edges.empty:
    sugg_edges = filter_edges(sugg_edges)

if sugg_edges is None or sugg_edges.empty:
    st.info("Need edges to suggest parlays.")
else:
    work = sugg_edges.copy()
    # Normalize fields expected by the engine
    if "dec_odds" not in work.columns and "odds" in work.columns:
        def _to_dec(o):
            try:
                o = float(str(o).replace("+",""))
                return 1.0 + (o/100.0) if o >= 100 else 1.0 + (100.0/abs(o)) if o <= -100 else 1.0
            except Exception:
                return 1.0
        work["dec_odds"] = work["odds"].map(_to_dec)
    if "p_win" not in work.columns:
        work["p_win"] = work["dec_odds"].apply(lambda d: 1.0/float(d) if pd.notna(d) and d and d>0 else np.nan)
    work = work.dropna(subset=["p_win","dec_odds"])

    def leg_label(row):
        return str(row.get("side") or row.get("ref") or row.get("market") or "")
    work["__label"] = work.apply(leg_label, axis=1)

    c1, c2, c3, c4 = st.columns(4)
    MAX_SUGGESTIONS = c1.number_input("Max suggestions", 1, 50, 5, step=1, key="sugg_max_n")
    MIN_LEGS = c2.number_input("# legs min", 2, 8, 3, step=1, key="sugg_min_legs")
    MAX_LEGS = c3.number_input("# legs max", 2, 8, 5, step=1, key="sugg_max_legs2")
    TARGET_DEC_MIN = c4.number_input("Target decimal min", 1.0, 50.0, 6.5, step=0.1, key="sugg_tmin2")
    TARGET_DEC_MAX = st.number_input("Target decimal max", 1.0, 100.0, 8.75, step=0.25, key="sugg_tmax2")

    def per_leg_ev(row) -> float:
        d = float(row["dec_odds"]); p = float(row["p_win"])
        return p * (d - 1.0) - (1 - p)

    work["__ev"] = work.apply(per_leg_ev, axis=1)
    pool = work.sort_values("__ev", ascending=False).head(40)
    pool_records = pool.to_dict("records")

    # Build suggestions
    from itertools import combinations
    suggestions = []

    def correlation_guard(legs: list[dict]) -> bool:
        gids = [str(lg.get("game_id") or lg.get("gid") or "") for lg in legs if lg]
        return len(gids) == len(set(gids))

    def parlay_stats_sugg(legs: list[dict]):
        decs = []; probs = []
        for lg in legs:
            d = float(lg.get("dec_odds") or 1.0); decs.append(d)
            p = float(lg.get("p_win") or 0.0);  probs.append(p)
        par_dec = float(pd.Series(decs).prod()) if decs else 1.0
        p_win   = float(pd.Series(probs).prod()) if probs else 0.0
        if par_dec <= 1.0:
            am = -1000000
        else:
            am = int(round((par_dec-1)*100)) if par_dec >= 2 else int(round(-100/(par_dec-1)))
        ev = p_win * (par_dec - 1.0) - (1 - p_win)
        return par_dec, am, p_win, ev

    def try_push(legs):
        if not correlation_guard(legs): return
        par_dec, par_am, p, ev = parlay_stats_sugg(legs)
        if not (TARGET_DEC_MIN <= par_dec <= TARGET_DEC_MAX): return
        suggestions.append({"legs": legs, "par_dec": par_dec, "par_am": par_am, "p_win": p, "ev": ev})

    for r in range(int(MIN_LEGS), int(MAX_LEGS)+1):
        for combo in combinations(pool_records, r):
            try_push(list(combo))
            if len(suggestions) >= MAX_SUGGESTIONS * 5:
                break

    suggestions.sort(key=lambda s: s["ev"], reverse=True)
    suggestions = suggestions[:MAX_SUGGESTIONS]

    if not suggestions:
        st.warning("No viable suggestions under current filters.")
    else:
        st.success(f"Built {len(suggestions)} suggestion(s).")

        PARLAY_COLS = ["ts","market","odds","p_win","ev","stake","status","result","pnl","tag","legs_json","parlay_id","notes"]

        def log_suggestion(sugg):
            # Append to exports/parlays.csv in your original schema, tag as 'suggested'
            now = datetime.datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC")
            legs = sugg["legs"]
            # Store original legs object as legs_json; your bet log page can parse
            row = {
                "ts": now,
                "market": "parlay",
                "odds": int(sugg["par_am"]),
                "p_win": float(sugg["p_win"]),
                "ev": float(sugg["ev"]),
                "stake": None,
                "status": "open",
                "result": None,
                "pnl": None,
                "tag": "suggested",
                "legs_json": json.dumps(legs),
                "parlay_id": uuid.uuid4().hex[:12],
                "notes": "computer-suggested",
            }
            try:
                cur = pd.read_csv(PARLAYS_CSV, encoding="utf-8-sig")
            except Exception:
                cur = pd.DataFrame(columns=PARLAY_COLS)
            for c in PARLAY_COLS:
                if c not in cur.columns:
                    cur[c] = pd.NA
            cur = pd.concat([cur, pd.DataFrame([row])[PARLAY_COLS]], ignore_index=True)
            cur.to_csv(PARLAYS_CSV, index=False, encoding="utf-8-sig")
            st.success("Logged suggestion to exports/parlays.csv")

        for idx, s in enumerate(suggestions, start=1):
            with st.expander(f"Suggestion #{idx}  —  Odds {s['par_am']}  |  Win {s['p_win']:.1%}  |  EV ${s['ev']:+.2f}"):
                legs_df = pd.DataFrame([{
                    "game_id": lg.get("game_id") or lg.get("gid"),
                    "market": lg.get("market"),
                    "side": lg.get("side") or lg.get("__label"),
                    "line": lg.get("line"),
                    "book": lg.get("book"),
                    "odds": lg.get("odds"),
                    "dec_odds": lg.get("dec_odds"),
                    "p_win": lg.get("p_win"),
                    "ref": lg.get("ref")
                } for lg in s["legs"]])
                st.dataframe(legs_df, use_container_width=True, hide_index=True)
                cL, cR = st.columns([1,1])
                if cL.button(f"Log Suggestion #{idx}", key=f"sugg_log_{idx}"):
                    log_suggestion(s)
                if cR.button(f"? Use Suggestion #{idx}", key=f"sugg_use_{idx}"):
                    cur = st.session_state.get("picked_legs", [])
                    for lg in s["legs"]:
                        cur.append({
                            "game_id": lg.get("game_id"),
                            "market":  lg.get("market"),
                            "side":    lg.get("side") or lg.get("__label"),
                            "line":    lg.get("line"),
                            "book":    lg.get("book"),
                            "odds":    lg.get("odds"),
                            "p_win":   lg.get("p_win"),
                            "ref":     lg.get("ref") or uuid.uuid4().hex[:8],
                        })
                    st.session_state["picked_legs"] = cur
                    st.success("Suggestion legs added to current parlay.")
                    st.rerun()




