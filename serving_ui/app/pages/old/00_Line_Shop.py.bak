# === BootAuth block (drop-in, top of file) ===
from __future__ import annotations
import sys
from pathlib import Path
import streamlit as st

# Make 'app' importable no matter where Streamlit is launched
_here = Path(__file__).resolve()
for up in [_here] + list(_here.parents):
    cand = up / "serving_ui" / "app" / "__init__.py"
    if cand.exists():
        base = str((up / "serving_ui").resolve())
        if base not in sys.path:
            sys.path.insert(0, base)
        break

# Auth
from app.lib.auth import login, show_logout  # requires the shim we made
PAGE_PROTECTED = False  # set True on pages that must require login

auth = login(required=PAGE_PROTECTED)  # supports 'required='
if not auth.ok:
    st.stop()

show_logout()
# === /BootAuth block ===

from __future__ import annotations
import sys
from pathlib import Path
import streamlit as st
_here = Path(__file__).resolve()
for up in [_here] + list(_here.parents):
    cand = up / "serving_ui" / "app" / "__init__.py"
    if cand.exists():
        base = str((up / "serving_ui").resolve())
        if base not in sys.path:
            sys.path.insert(0, base)
        break
from app.lib.auth import login, show_logout
PAGE_PROTECTED = False
auth = login(required=PAGE_PROTECTED)
if not auth.ok:
    st.stop()
show_logout()
# === /BootAuth block ===


import streamlit as st
from app.lib.auth import login, show_logout
# === Auth (auto-injected) ===
import streamlit as st  # ensured
from app.lib.auth import login, show_logout

auth = login(required=False)   # or required=True for protected pages
if not auth.authenticated:
    st.info("You are in read-only mode.")
show_logout()  # sidebar logout
# === /Auth (auto-injected) ===

import streamlit as st
# --- import bootstrap so 'app' package is importable when run from anywhere ---
import sys
from pathlib import Path
_HERE = Path(__file__).resolve()
# file: .../serving_ui/app/pages/<page>.py  -> parents[2] = .../serving_ui
_SERVING_UI = _HERE.parents[2]
if str(_SERVING_UI) not in sys.path:
    sys.path.insert(0, str(_SERVING_UI))
from app.lib.access import live_enabled

if live_enabled():
    # do live fetch / recompute / write / API calls
    do_expensive_refresh()
else:
    # skip; rely on cached CSVs in /exports that your app already loads
    pass

# -----------------------------------------------------------------------------import streamlit as st
st.set_page_config(page_title='01 Line Shop', page_icon='üìà', layout='wide')

import streamlit as st

import streamlit as st


import streamlit as st

# --- diagnostics import (robust) ---
try:
    from app.utils.diagnostics import mount_in_sidebar
except ModuleNotFoundError:
    try:
        import sys
        from pathlib import Path as _efP
        # add repo/serving_ui to sys.path so 'app' is importable
        sys.path.append(str(_efP(__file__).resolve().parents[3]))
        from app.utils.diagnostics import mount_in_sidebar
    except Exception:
        try:
            # fallback if pages run with CWD=app
            from utils.diagnostics import mount_in_sidebar
        except Exception:
            def mount_in_sidebar(page_name: str):
                return None
# --- /diagnostics import (robust) ---
# 01_Line_Shop.py ‚Äî full drop-in
import os, sys, subprocess, time, re
from datetime import datetime
from pathlib import Path
import pandas as pd
import numpy as np
import streamlit as st
from app.utils.parlay_ui import selectable_odds_table
from app.utils.parlay_cart import read_cart, clear_cart

# ---------- repo/exports detection ----------
def _repo_root() -> Path:
    env = os.environ.get("EDGE_FINDER_ROOT")
    if env and Path(env).exists(): return Path(env)
    here = Path(__file__).resolve()
    for up in [here] + list(here.parents):
        if (up / "exports").exists(): return up
    return Path.cwd()

REPO = _repo_root()
EXPORTS = REPO / "exports"
EXPORTS.mkdir(parents=True, exist_ok=True)

# ---------- optional workflow buttons ----------
def _find_script(cands: list[str]) -> Path | None:
    for rel in cands:
        p = REPO / rel
        if p.exists(): return p
    return None

ODDS_PULLER = _find_script(["tools/pull_lines.py","tools/pull_odds.py","serving/pull_lines.py"])
EDGE_SCANNER = _find_script(["tools/scan_edges.py","serving/scan_edges.py"])

def _run(label: str, script: Path) -> tuple[int,str,str]:
    try:
        proc = subprocess.run([sys.executable, str(script)], cwd=str(script.parent),
                              capture_output=True, text=True, timeout=300)
        return proc.returncode, proc.stdout, proc.stderr
    except Exception as e:
        return -1, "", f"{label} error: {e}"

with st.expander("‚öôÔ∏è Workflow controls", expanded=False):
    colA, colB, colC, colD = st.columns([1,1,1,2])
    with colA:
        upd_lines = st.button("Update Lines", disabled=not bool(ODDS_PULLER))
    with colB:
        scan_edges = st.button("Scan Edges", disabled=not bool(EDGE_SCANNER))
    with colC:
        both = st.button("Update Lines + Edges",
                         disabled=not (ODDS_PULLER and EDGE_SCANNER))
    with colD:
        auto = st.toggle("Auto-reload", value=False)
        every = st.number_input("Seconds", 5, 3600, 30, 5)
        if auto:
            st.markdown(
                f"<script>setTimeout(() => window.location.reload(), {int(every)*1000});</script>",
                unsafe_allow_html=True
            )
    log = st.empty()

    def _done():
        try: st.cache_data.clear()
        except Exception: pass
        st.rerun()

    if upd_lines and ODDS_PULLER:
        rc,o,e = _run("Odds pull", ODDS_PULLER); log.code((o or "")+("\n"+e if e else ""), language="bash")
        st.success(f"Odds puller rc={rc}. Wrote {EXPORTS/'lines_live.csv'} @ {datetime.now():%H:%M:%S}."); _done()
    if scan_edges and EDGE_SCANNER:
        rc,o,e = _run("Edge scan", EDGE_SCANNER); log.code((o or "")+("\n"+e if e else ""), language="bash")
        st.success(f"Edge scanner rc={rc}. Wrote {EXPORTS/'edges.csv'} @ {datetime.now():%H:%M:%S}."); _done()
    if both and ODDS_PULLER and EDGE_SCANNER:
        rc1,o1,e1 = _run("Odds pull", ODDS_PULLER)
        rc2,o2,e2 = _run("Edge scan", EDGE_SCANNER)
        log.code("\n\n".join([o1+(("\n"+e1) if e1 else ""), o2+(("\n"+e2) if e2 else "")]).strip(), language="bash")
        st.success(f"Updated lines & edges (rcs={rc1},{rc2})."); _done()

# ---------- page header ----------
diag = mount_in_sidebar("01_Line_Shop")
st.title("Line Shop")

def _age_str(p: Path) -> str:
    try:
        if not p.exists(): return "missing"
        secs = max(0, int(time.time() - p.stat().st_mtime))
        if secs < 60: return f"{secs}s"
        mins = secs // 60
        if mins < 60: return f"{mins}m"
        hrs = mins // 60
        if hrs < 48: return f"{hrs}h"
        days = hrs // 24
        return f"{days}d"
    except Exception:
        return "n/a"

_lines_p = EXPORTS / "lines_live.csv"
_edges_p = EXPORTS / "edges.csv"
st.caption(f"lines_live.csv age: {_age_str(_lines_p)} ¬∑ edges.csv age: {_age_str(_edges_p)} ¬∑ exports: {EXPORTS}")

CSV   = EXPORTS / "lines_live.csv"
MODEL = EXPORTS / "model_probs.csv"  # optional

# ---------- helpers ----------
def american_to_decimal(odds):
    try: o = float(odds)
    except: return np.nan
    if o > 0: return 1.0 + (o/100.0)
    if o < 0: return 1.0 + (100.0/abs(o))
    return np.nan

def implied_prob(odds):
    try: o = float(odds)
    except: return np.nan
    if o > 0: return 100.0/(o+100.0)
    if o < 0: return abs(o)/(abs(o)+100.0)
    return np.nan

def ev_percent(p, dec):
    if pd.isna(p) or pd.isna(dec) or dec <= 1.0: return np.nan
    b = dec - 1.0
    return 100.0*(p*b - (1.0 - p))

def ev_dollars(p, dec, stake):
    if pd.isna(p) or pd.isna(dec) or dec <= 1.0: return np.nan
    b = dec - 1.0
    return stake*(p*b - (1.0 - p))

def kelly_fraction(p, dec):
    if pd.isna(p) or pd.isna(dec) or dec <= 1.0: return 0.0
    b = dec - 1.0
    f = (p*b - (1.0 - p)) / b
    return max(0.0, float(f))

def best_rows(df):
    d = df.copy()
    d["Decimal"] = d["American"].apply(american_to_decimal)
    d["_rank"] = d.groupby(["game_id","market","selection"])["Decimal"].rank(ascending=False, method="first")
    return d[d["_rank"] == 1.0].drop(columns=["_rank"])

def load_model_probs():
    if not MODEL.exists() or MODEL.stat().st_size == 0: return None
    mp = pd.read_csv(MODEL)
    mp.columns = [c.lower().strip() for c in mp.columns]
    need = {"game_id","market","selection","prob"}
    if not need.issubset(mp.columns):
        st.warning(f"model_probs.csv missing {sorted(list(need - set(mp.columns)))}; EV/Kelly disabled.")
        return None
    mp["prob"] = pd.to_numeric(mp["prob"], errors="coerce").clip(0,1)
    return mp.dropna(subset=["prob"])

def read_lines():
    if not CSV.exists() or CSV.stat().st_size == 0: return pd.DataFrame()
    df = pd.read_csv(CSV)
    cols = ["pulled_ts","game_id","commence_time","home","away","book","market","selection","price_american","point"]
    missing = [c for c in cols if c not in df.columns]
    if missing:
        st.error(f"lines_live.csv missing columns: {missing}")
        return pd.DataFrame()
    df = df.rename(columns={"price_american":"American", "point":"Line/Point"})
    df["American"] = pd.to_numeric(df["American"], errors="coerce")
    df["commence_time"] = pd.to_datetime(df["commence_time"], errors="coerce")
    return df
# 01_Line_Shop.py  ‚Äì after your "Update Lines" logic succeeds
from tools.lines_archiver import archive_lines, build_open_close
import pandas as pd

colA, colB = st.columns(2)
with colA:
    if st.button("Snapshot (archive this pull)", use_container_width=True):
        out = archive_lines()
        st.success(f"Archived snapshot: {out}")
        st.cache_data.clear(); st.rerun()

with colB:
    if st.button("Build Open/Close for today", use_container_width=True):
        today = pd.Timestamp.now(tz="America/New_York").strftime("%Y-%m-%d")
        o, c = build_open_close(today)
        st.success(f"Open {o.shape}  ¬∑  Close {c.shape}")
        st.cache_data.clear(); st.rerun()

# ---------- Sidebar filters ----------
st.sidebar.header("Filters")
team_q    = st.sidebar.text_input("Team search (home/away contains)")
market    = st.sidebar.selectbox("Market", ["all","h2h","spreads","totals"], index=0)
min_books = st.sidebar.number_input("Min # of books per selection", 1, 20, 1, 1)

st.sidebar.header("EV & Kelly")
stake_display = st.sidebar.number_input("EV display stake ($)", 1, 10000, 100, 25)
show_pos_ev   = st.sidebar.toggle("Show only +EV (needs model_probs)", value=False)
min_ev_pct    = st.sidebar.number_input("Min EV %", value=0.0, step=0.5)

bankroll      = st.sidebar.number_input("Bankroll ($)", 0, 10_000_000, 1000, 50)
kelly_cap     = st.sidebar.number_input("Kelly fraction cap (0..1)", 0.0, 1.0, 0.25, 0.05)

# ---------- Load + filter ----------
df = read_lines()
if df.empty:
    st.warning("No live odds found. Populate exports/lines_live.csv.")
    st.stop()

if team_q:
    s = team_q.strip().lower()
    df = df[df["home"].str.lower().str.contains(s) | df["away"].str.lower().str.contains(s)]
if market != "all":
    df = df[df["market"] == market]

books = sorted(df["book"].dropna().unique().tolist())
chosen_books = st.sidebar.multiselect("Books", books, default=books)
if chosen_books:
    df = df[df["book"].isin(chosen_books)]

counts = df.groupby(["game_id","market","selection"])["book"].nunique().rename("#Books")
df = df.merge(counts, on=["game_id","market","selection"], how="left")
df = df[df["#Books"] >= int(min_books)]

mp = load_model_probs()
if mp is not None:
    df = df.merge(mp, on=["game_id","market","selection"], how="left")
    df.rename(columns={"prob":"Model Prob"}, inplace=True)

df["Decimal"] = df["American"].apply(american_to_decimal)
df["Impl. Prob (Odds)"] = df["American"].apply(implied_prob)

if "Model Prob" in df.columns:
    df["EV %"]      = df.apply(lambda r: ev_percent(r["Model Prob"], r["Decimal"]), axis=1)
    df[f"EV @ ${stake_display}"] = df.apply(lambda r: ev_dollars(r.get("Model Prob"), r["Decimal"], stake_display), axis=1)
    df["Kelly f"]   = df.apply(lambda r: kelly_fraction(r.get("Model Prob"), r["Decimal"]), axis=1)
    df["Kelly stake ($)"] = (df["Kelly f"].clip(lower=0) * kelly_cap * bankroll).round(2)
else:
    df["EV %"] = df[f"EV @ ${stake_display}"] = df["Kelly f"] = df["Kelly stake ($)"] = np.nan

if show_pos_ev and "EV %" in df.columns:
    df = df[df["EV %"].fillna(-999) >= float(min_ev_pct)]

base_cols = ["commence_time","home","away","market","selection","book","American","Line/Point","Decimal","Impl. Prob (Odds)","#Books"]
ev_cols   = ["Model Prob","EV %",f"EV @ ${stake_display}","Kelly f","Kelly stake ($)"] if "Model Prob" in df.columns else []
show_cols = [c for c in base_cols + ev_cols if c in df.columns]

tab_best, tab_all = st.tabs(["Quick Odds Shop (Best Price)", "All Quotes"])

with tab_best:
    best = best_rows(df)
    st.caption("Best price per (game_id, market, selection).")
    st.dataframe(best[show_cols], use_container_width=True, hide_index=True)

    # ---- selection ‚Üí bet slip ----
    st.subheader("Pick rows to add to Bet Slip")
    best = best.assign(_id=(best["game_id"] + "|" + best["market"] + "|" + best["selection"] + "|" + best["book"].astype(str)))
    labels = (best["home"] + " @ " + best["away"] + " ‚Ä¢ " + best["market"] + " ‚Ä¢ " + best["selection"] + " ‚Ä¢ " + best["book"]).tolist()
    choice_map = dict(zip(labels, best["_id"]))
    picked = st.multiselect("Choose one or more", labels, key="ls_picklist")

    if "bet_slip" not in st.session_state:
        st.session_state["bet_slip"] = []

    if st.button("‚ûï Add selected to Bet Slip", disabled=(len(picked)==0)):
        ids = {choice_map[lbl] for lbl in picked}
        add = best[best["_id"].isin(ids)]
        to_add = add.assign(stake=np.where(pd.notna(add.get("Kelly stake ($)")), add["Kelly stake ($)"], 0.0))
        st.session_state["bet_slip"].extend(to_add.to_dict("records"))
        st.success(f"Added {len(to_add)} selections.")

with tab_all:
    st.dataframe(df[show_cols], use_container_width=True, hide_index=True)

st.markdown("---")
st.header("üßæ Bet Slip")
slip = pd.DataFrame(st.session_state.get("bet_slip", []))
if slip.empty:
    st.info("Bet Slip is empty. Use the Best tab to add picks.")
else:
    display_cols = [c for c in ["home","away","market","selection","book","American","Decimal","Model Prob","EV %","Kelly f","Kelly stake ($)","stake"] if c in slip.columns]
    st.dataframe(slip[display_cols], use_container_width=True, hide_index=True)
    if "stake" in slip.columns:
        st.write(f"**Total stake:** ${float(pd.to_numeric(slip['stake'], errors='coerce').fillna(0).sum()):,.2f}")
    if st.button("üóëÔ∏è Clear Bet Slip"):
        st.session_state["bet_slip"] = []
        st.rerun()

# --- _EF_DIAG_SNAPSHOT_ (auto-added) ---
try:
    import pandas as _ef_pd
    from pathlib import Path as _ef_Path
    _ef = locals().get("diag", None)
    if _ef:
        for _nm in ("edges_p","live_p","oc_path","edges_path","live_path","scores_path","scores_p","epath","spath","_lines_p","_edges_p"):
            _p = locals().get(_nm, None)
            if _p:
                try: _ef.check_file(_ef_Path(str(_p)), required=False, label=_nm)
                except Exception: pass
        for _dfn in ("edges","live","oc","scores","joined","view"):
            _df = locals().get(_dfn, None)
            try:
                if isinstance(_df, _ef_pd.DataFrame):
                    _ef.log_df(_df, _dfn)
            except Exception:
                pass
except Exception:
    pass
# --- /_EF_DIAG_SNAPSHOT_ ---




# --- AUTO-APPENDED: add-to-cart selector ---
try:
    if "df" in globals() and isinstance(df, pd.DataFrame):
        selectable_odds_table(df, page_key="line_shop", page_name="01_Line_Shop")
except Exception as _e:
    pass









