from __future__ import annotations
import sys, json, math, datetime as dt
from pathlib import Path
from typing import Dict, List, Tuple, Optional

import numpy as np
import pandas as pd
import streamlit as st

# ---------- Paths ----------
HERE = Path(__file__).resolve()
APP_DIR  = HERE.parents[1]          # .../serving_ui/app
REPO_DIR = APP_DIR.parents[1]       # repo root
EXPORTS  = REPO_DIR / "exports"
BETLOG   = EXPORTS / "bets_log.csv"

if str(REPO_DIR) not in sys.path:
    sys.path.insert(0, str(REPO_DIR))

st.set_page_config(page_title="Backtest ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ Calculated Risk", page_icon="ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â°ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¸ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â§ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Âª", layout="wide")
st.title("ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â°ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¸ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â§ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Âª Backtest")

# ---------- IO ----------
@st.cache_data(show_spinner=False)
def _read_csv_safe(path: Path) -> pd.DataFrame:
    try:
        if not path.exists() or path.stat().st_size == 0:
            return pd.DataFrame()
        df = pd.read_csv(path)
        df.columns = [c.strip().lower() for c in df.columns]
        return df
    except Exception:
        return pd.DataFrame()

# ---------- Helpers ----------
def american_to_decimal(odds: float) -> float:
    o = float(odds)
    return 1.0 + (o/100.0 if o > 0 else 100.0/abs(o))

def settle_row(r) -> tuple[float, bool]:
    try:
        stake = float((r.get("stake", 0) if hasattr(r, "get") else r["stake"]) or 0)
        odds  = float((r.get("odds", 0)  if hasattr(r, "get") else r["odds"])  or 0)
        res   = (r.get("result","") if hasattr(r,"get") else r.get("result",""))
        res   = str(res or "").lower()
        dec   = american_to_decimal(odds)
        if res in ("win","won","w"):   return stake * (dec - 1.0), True
        if res in ("lose","lost","l"): return -stake, True
        if res in ("push","void","cancel","canceled","cancelled"): return 0.0, True
        return 0.0, False
    except Exception:
        return 0.0, False

def classify_market(val: str) -> str:
    t = str(val or "").lower()
    groups = {
        "Moneyline":   ["ml","moneyline","money line","money-line"],
        "Spread":      ["spread","ats","handicap","point spread"],
        "Total (O/U)": ["total","totals","o/u","over/under","ou"],
        "Props":       ["prop","props","player","passing","rushing","receiving","td","interception","tackles","sacks"],
        "Parlay":      ["parlay"],
    }
    for g, kws in groups.items():
        if any(kw in t for kw in kws): return g
    if t == "total": return "Total (O/U)"
    return "Other"

def normalize(df: pd.DataFrame) -> pd.DataFrame:
    if df is None or df.empty: return pd.DataFrame()
    x = df.copy()
    x.columns = [c.strip().lower() for c in x.columns]

    # soft ensure columns we use later
    for c in ["stake","odds","p_win","result","market","placed_at","ts","season","week"]:
        if c not in x.columns: x[c] = None

    # numeric casts
    for c in ("stake","odds","p_win"):
        x[c] = pd.to_numeric(x[c], errors="coerce")

    # timestamps
    placed = pd.to_datetime(x.get("placed_at"), errors="coerce", utc=True)
    ts     = pd.to_datetime(x.get("ts"), errors="coerce", utc=True)
    x["placed_at"] = placed.where(placed.notna(), ts)

    # infer season/week when missing
    x["season"] = pd.to_numeric(x.get("season"), errors="coerce")
    if "season" in x and x["season"].isna().all():
        x["season"] = x["placed_at"].dt.year
    x["season"] = x["season"].astype("Int64")

    w = pd.to_numeric(x.get("week"), errors="coerce")
    if w is None or (hasattr(w,"isna") and w.isna().all()):
        x["week"] = x["placed_at"].dt.isocalendar().week.astype("Int64")
    else:
        x["week"] = w.astype("Int64")

    # market grouping
    x["market_group"] = x["market"].apply(classify_market)
    return x

def compute_realized_pnl(df: pd.DataFrame) -> pd.DataFrame:
    if df.empty: return df
    if "pnl" in df and pd.to_numeric(df["pnl"], errors="coerce").fillna(0).abs().sum() > 0:
        return df
    pnl = []
    for _, r in df.iterrows():
        v, settled = settle_row(r)
        pnl.append(v if settled else 0.0)
    df = df.copy()
    df["pnl"] = pnl
    return df

# ---------- Load ----------
bets = normalize(_read_csv_safe(BETLOG))
st.caption(f"Reading: {BETLOG}")

if bets.empty:
    st.warning("No bets found. Populate exports/bets_log.csv.")
    st.stop()

bets = compute_realized_pnl(bets)

# ---------- Sidebar Filters ----------
with st.sidebar:
    st.header("Filters")

    # Seasons / Weeks
    seasons = sorted([int(s) for s in pd.Series(bets["season"]).dropna().unique()])
    default_seasons = seasons[-1:] if seasons else []
    sel_seasons = st.multiselect("Season", seasons, default=default_seasons)

    weeks = sorted([int(w) for w in pd.Series(bets["week"]).dropna().unique()])
    default_weeks = weeks if len(weeks) <= 18 else weeks[-18:]
    sel_weeks = st.multiselect("Week", weeks, default=default_weeks)

    # Date window
    min_dt = pd.to_datetime(bets["placed_at"]).min()
    max_dt = pd.to_datetime(bets["placed_at"]).max()
    date_from, date_to = st.date_input(
        "Placed date range",
        value=(min_dt.date() if pd.notna(min_dt) else dt.date.today(),
               max_dt.date() if pd.notna(max_dt) else dt.date.today()),
        format="YYYY-MM-DD"
    )

    # Markets / Results
    groups = sorted(pd.Series(bets["market_group"]).dropna().unique().tolist())
    sel_groups = st.multiselect("Market groups", groups, default=groups)

    result_opts = ["win","lose","push","open/unknown"]
    sel_result  = st.multiselect("Result status", result_opts, default=result_opts)

    # Odds window
    min_odds = int(pd.to_numeric(bets["odds"], errors="coerce").min(skipna=True) or -1000)
    max_odds = int(pd.to_numeric(bets["odds"], errors="coerce").max(skipna=True) or 1000)
    lo = st.number_input("Min odds (American)", value=min_odds, step=5)
    hi = st.number_input("Max odds (American)", value=max_odds, step=5)

# ---------- Apply filters ----------
mask = pd.Series(True, index=bets.index)

if sel_seasons:
    mask &= bets["season"].isin(sel_seasons)
if sel_weeks:
    mask &= bets["week"].isin(sel_weeks)
if sel_groups:
    mask &= bets["market_group"].isin(sel_groups)

# Result filter
if sel_result and len(sel_result) < 4:
    r = bets.get("result","").astype(str).str.lower()
    open_mask = ~r.isin(["win","won","w","lose","lost","l","push","void","cancel","canceled","cancelled"])
    conds = []
    if "win" in sel_result:  conds.append(r.isin(["win","won","w"]))
    if "lose" in sel_result: conds.append(r.isin(["lose","lost","l"]))
    if "push" in sel_result: conds.append(r.isin(["push","void","cancel","canceled","cancelled"]))
    if "open/unknown" in sel_result: conds.append(open_mask)
    res_mask = conds[0]
    for c in conds[1:]: res_mask |= c
    mask &= res_mask

# Date range
if isinstance(date_from, dt.date) and isinstance(date_to, dt.date):
    dfrom = pd.Timestamp(date_from)
    dto   = pd.Timestamp(date_to) + pd.Timedelta(days=1)
    # make placed_at tz-naive for comparison
_pa = pd.to_datetime(bets["placed_at"], errors="coerce", utc=True).dt.tz_localize(None)
mask &= (_pa >= dfrom) & (_pa < dto)

# Odds window
bets["odds_num"] = pd.to_numeric(bets["odds"], errors="coerce")
mask &= (bets["odds_num"] >= float(lo)) & (bets["odds_num"] <= float(hi))

filtered = bets[mask].copy()

# ---------- Summary ----------
total_staked = float(pd.to_numeric(filtered.get("stake"), errors="coerce").fillna(0).sum())
realized_pnl = float(pd.to_numeric(filtered.get("pnl"), errors="coerce").fillna(0).sum())
roi = (realized_pnl / total_staked) if total_staked else np.nan

wins = (filtered.get("result","").astype(str).str.lower().isin(["win","won","w"]).sum()
        if "result" in filtered else np.nan)
losses = (filtered.get("result","").astype(str).str.lower().isin(["lose","lost","l"]).sum()
          if "result" in filtered else np.nan)
pushes = (filtered.get("result","").astype(str).str.lower().isin(["push","void","cancel","canceled","cancelled"]).sum()
          if "result" in filtered else np.nan)

c1,c2,c3,c4,c5 = st.columns(5)
with c1: st.metric("Bets", f"{len(filtered):,}")
with c2: st.metric("Wins",   f"{wins}"   if wins==wins     else "ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â")
with c3: st.metric("Losses", f"{losses}" if losses==losses else "ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â")
with c4: st.metric("Pushes", f"{pushes}" if pushes==pushes else "ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â")
with c5: st.metric("ROI", f"{roi*100:.2f}%" if roi==roi else "ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â")


# ---------- Equity Curve & Drawdown ----------
st.subheader("Bankroll equity & drawdown")

start_bank = st.number_input("Starting bankroll (units)", min_value=0.0, value=100.0, step=10.0, help="Used for the bankroll line")

def _equity_table(df: pd.DataFrame, start_bankroll: float) -> pd.DataFrame:
    if df is None or df.empty:
        return pd.DataFrame(columns=["placed_at","bankroll","running_max","drawdown"])
    x = df.sort_values("placed_at").copy()
    x["pnl_realized"] = pd.to_numeric(x.get("pnl"), errors="coerce").fillna(0.0)
    x["equity"] = x["pnl_realized"].cumsum()  # cumulative PnL in units
    x["bankroll"] = float(start_bankroll) + x["equity"]
    x["running_max"] = x["bankroll"].cummax()
    x["drawdown"] = x["bankroll"] - x["running_max"]
    return x[["placed_at","bankroll","running_max","drawdown"]]

curve = _equity_table(filtered, start_bank)

# draw chart
if not curve.empty:
    st.line_chart(curve.assign(placed_at=pd.to_datetime(curve["placed_at"], utc=True).dt.tz_localize(None)).set_index("placed_at")[["bankroll","running_max"]], use_container_width=True)
    # max and longest drawdown
    max_dd_units = float(curve["drawdown"].min())
    in_dd = curve["bankroll"] < curve["running_max"]
    # longest consecutive in-drawdown stretch (bets)
    longest_dd = 0
    current = 0
    for v in in_dd:
        if v: current += 1
        else:
            longest_dd = max(longest_dd, current)
            current = 0
    longest_dd = max(longest_dd, current)

    c1, c2 = st.columns(2)
    with c1: st.metric("Max drawdown (units)", f"{max_dd_units:.2f}")
    with c2: st.metric("Longest drawdown (bets)", f"{longest_dd}")

    with st.expander("Equity data"):
        st.dataframe(curve, use_container_width=True, height=240)
else:
    st.info("No points to chart after filters.")
# ---------- Breakdowns ----------
left, right = st.columns(2)

with left:
    st.subheader("By season / week")
    grp = (filtered.assign(season=filtered["season"].astype("Int64"),
                           week=filtered["week"].astype("Int64"))
            .groupby(["season","week"], dropna=False)
            .agg(bets=("season","size"),
                 staked=("stake","sum"),
                 pnl=("pnl","sum"))
            .assign(roi=lambda d: d["pnl"]/d["staked"].replace(0,np.nan))
            .reset_index()
          )
    st.dataframe(grp.sort_values(["season","week"]), use_container_width=True, height=350)

with right:
    st.subheader("By market group")
    bym = (filtered.groupby("market_group", dropna=False)
                  .agg(bets=("market_group","size"),
                       staked=("stake","sum"),
                       pnl=("pnl","sum"))
                  .assign(roi=lambda d: d["pnl"]/d["staked"].replace(0,np.nan))
                  .reset_index())
    st.dataframe(bym.sort_values("bets", ascending=False), use_container_width=True, height=350)

st.subheader("Bet log")
st.dataframe(filtered.sort_values("placed_at").reset_index(drop=True), use_container_width=True)