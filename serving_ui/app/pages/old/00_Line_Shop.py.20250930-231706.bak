from __future__ import annotations
# === AppImportGuard (nuclear) ===
try:
    from app.lib.auth import login, show_logout
except ModuleNotFoundError:
    import sys
    from pathlib import Path
    here = Path(__file__).resolve()

    base = None
    auth_path = None
    for p in [here] + list(here.parents):
        cand1 = p / "app" / "lib" / "auth.py"
        cand2 = p / "serving_ui" / "app" / "lib" / "auth.py"
        if cand1.exists():
            base, auth_path = p, cand1
            break
        if cand2.exists():
            base, auth_path = (p / "serving_ui"), cand2
            break

    if base and auth_path:
        s = str(base)
        if s not in sys.path:
            sys.path.insert(0, s)
        try:
            from app.lib.auth import login, show_logout  # type: ignore
        except ModuleNotFoundError:
            import types, importlib.util
            if "app" not in sys.modules:
                pkg_app = types.ModuleType("app")
                pkg_app.__path__ = [str(Path(base) / "app")]
                sys.modules["app"] = pkg_app
            if "app.lib" not in sys.modules:
                pkg_lib = types.ModuleType("app.lib")
                pkg_lib.__path__ = [str(Path(base) / "app" / "lib")]
                sys.modules["app.lib"] = pkg_lib
            spec = importlib.util.spec_from_file_location("app.lib.auth", str(auth_path))
            mod = importlib.util.module_from_spec(spec)  # type: ignore[arg-type]
            assert spec and spec.loader
            spec.loader.exec_module(mod)  # type: ignore[attr-defined]
            sys.modules["app.lib.auth"] = mod
            login = mod.login
            show_logout = mod.show_logout
    else:
        raise
# === /AppImportGuard ===


import sys
from pathlib import Path
import streamlit as st
_here = Path(__file__).resolve()
for up in [_here] + list(_here.parents):
    cand = up / 'serving_ui' / 'app' / '__init__.py'
    if cand.exists():
        base = str((up / 'serving_ui').resolve())
        if base not in sys.path:
            sys.path.insert(0, base)
        break
PAGE_PROTECTED = False
auth = login(required=PAGE_PROTECTED)
if not auth.ok:
    st.stop()
show_logout()
import sys
from pathlib import Path
_here = Path(__file__).resolve()
for up in [_here] + list(_here.parents):
    cand = up / 'serving_ui' / 'app' / '__init__.py'
    if cand.exists():
        base = str((up / 'serving_ui').resolve())
        if base not in sys.path:
            sys.path.insert(0, base)
        break
PAGE_PROTECTED = False
auth = login(required=PAGE_PROTECTED)
if not auth.ok:
    st.stop()
show_logout()
auth = login(required=False)
if not auth.authenticated:
    st.info('You are in read-only mode.')
show_logout()
import sys
from pathlib import Path
_HERE = Path(__file__).resolve()
_SERVING_UI = _HERE.parents[2]
if str(_SERVING_UI) not in sys.path:
    sys.path.insert(0, str(_SERVING_UI))
from app.lib.access import live_enabled
if live_enabled():
    do_expensive_refresh()
else:
    pass
st.set_page_config(page_title='01 Line Shop', page_icon='üìà', layout='wide')


# === Nudge (auto-injected) ===
try:
    from app.utils.nudge import bump_usage, show_nudge  # type: ignore
except Exception:
    bump_usage = lambda *a, **k: None
    def show_nudge(*a, **k): pass

# Count a lightweight interaction per page load
bump_usage("page_visit")

# Show a nudge once usage crosses threshold in the last 24h
show_nudge(feature="analytics", metric="page_visit", threshold=10, period="1D", demo_unlock=True, location="inline")
# === /Nudge (auto-injected) ===

try:
    from app.utils.diagnostics import mount_in_sidebar
except ModuleNotFoundError:
    try:
        import sys
        from pathlib import Path as _efP
        sys.path.append(str(_efP(__file__).resolve().parents[3]))
        from app.utils.diagnostics import mount_in_sidebar
    except Exception:
        try:
            from utils.diagnostics import mount_in_sidebar
        except Exception:

            def mount_in_sidebar(page_name: str):
                return None
import os, sys, subprocess, time, re
from datetime import datetime
from pathlib import Path
import pandas as pd
import numpy as np
from app.utils.parlay_ui import selectable_odds_table
from app.utils.parlay_cart import read_cart, clear_cart

def _repo_root() -> Path:
    env = os.environ.get('EDGE_FINDER_ROOT')
    if env and Path(env).exists():
        return Path(env)
    here = Path(__file__).resolve()
    for up in [here] + list(here.parents):
        if (up / 'exports').exists():
            return up
    return Path.cwd()
REPO = _repo_root()
EXPORTS = REPO / 'exports'
EXPORTS.mkdir(parents=True, exist_ok=True)

def _find_script(cands: list[str]) -> Path | None:
    for rel in cands:
        p = REPO / rel
        if p.exists():
            return p
    return None
ODDS_PULLER = _find_script(['tools/pull_lines.py', 'tools/pull_odds.py', 'serving/pull_lines.py'])
EDGE_SCANNER = _find_script(['tools/scan_edges.py', 'serving/scan_edges.py'])

def _run(label: str, script: Path) -> tuple[int, str, str]:
    try:
        proc = subprocess.run([sys.executable, str(script)], cwd=str(script.parent), capture_output=True, text=True, timeout=300)
        return (proc.returncode, proc.stdout, proc.stderr)
    except Exception as e:
        return (-1, '', f'{label} error: {e}')
with st.expander('‚öôÔ∏è Workflow controls', expanded=False):
    colA, colB, colC, colD = st.columns([1, 1, 1, 2])
    with colA:
        upd_lines = st.button('Update Lines', disabled=not bool(ODDS_PULLER))
    with colB:
        scan_edges = st.button('Scan Edges', disabled=not bool(EDGE_SCANNER))
    with colC:
        both = st.button('Update Lines + Edges', disabled=not (ODDS_PULLER and EDGE_SCANNER))
    with colD:
        auto = st.toggle('Auto-reload', value=False)
        every = st.number_input('Seconds', 5, 3600, 30, 5)
        if auto:
            st.markdown(f'<script>setTimeout(() => window.location.reload(), {int(every) * 1000});</script>', unsafe_allow_html=True)
    log = st.empty()

    def _done():
        try:
            st.cache_data.clear()
        except Exception:
            pass
        st.rerun()
    if upd_lines and ODDS_PULLER:
        rc, o, e = _run('Odds pull', ODDS_PULLER)
        log.code((o or '') + ('\n' + e if e else ''), language='bash')
        st.success(f"Odds puller rc={rc}. Wrote {EXPORTS / 'lines_live.csv'} @ {datetime.now():%H:%M:%S}.")
        _done()
    if scan_edges and EDGE_SCANNER:
        rc, o, e = _run('Edge scan', EDGE_SCANNER)
        log.code((o or '') + ('\n' + e if e else ''), language='bash')
        st.success(f"Edge scanner rc={rc}. Wrote {EXPORTS / 'edges.csv'} @ {datetime.now():%H:%M:%S}.")
        _done()
    if both and ODDS_PULLER and EDGE_SCANNER:
        rc1, o1, e1 = _run('Odds pull', ODDS_PULLER)
        rc2, o2, e2 = _run('Edge scan', EDGE_SCANNER)
        log.code('\n\n'.join([o1 + ('\n' + e1 if e1 else ''), o2 + ('\n' + e2 if e2 else '')]).strip(), language='bash')
        st.success(f'Updated lines & edges (rcs={rc1},{rc2}).')
        _done()
diag = mount_in_sidebar('01_Line_Shop')
st.title('Line Shop')

def _age_str(p: Path) -> str:
    try:
        if not p.exists():
            return 'missing'
        secs = max(0, int(time.time() - p.stat().st_mtime))
        if secs < 60:
            return f'{secs}s'
        mins = secs // 60
        if mins < 60:
            return f'{mins}m'
        hrs = mins // 60
        if hrs < 48:
            return f'{hrs}h'
        days = hrs // 24
        return f'{days}d'
    except Exception:
        return 'n/a'
_lines_p = EXPORTS / 'lines_live.csv'
_edges_p = EXPORTS / 'edges.csv'
st.caption(f'lines_live.csv age: {_age_str(_lines_p)} ¬∑ edges.csv age: {_age_str(_edges_p)} ¬∑ exports: {EXPORTS}')
CSV = EXPORTS / 'lines_live.csv'
MODEL = EXPORTS / 'model_probs.csv'

def american_to_decimal(odds):
    try:
        o = float(odds)
    except:
        return np.nan
    if o > 0:
        return 1.0 + o / 100.0
    if o < 0:
        return 1.0 + 100.0 / abs(o)
    return np.nan

def implied_prob(odds):
    try:
        o = float(odds)
    except:
        return np.nan
    if o > 0:
        return 100.0 / (o + 100.0)
    if o < 0:
        return abs(o) / (abs(o) + 100.0)
    return np.nan

def ev_percent(p, dec):
    if pd.isna(p) or pd.isna(dec) or dec <= 1.0:
        return np.nan
    b = dec - 1.0
    return 100.0 * (p * b - (1.0 - p))

def ev_dollars(p, dec, stake):
    if pd.isna(p) or pd.isna(dec) or dec <= 1.0:
        return np.nan
    b = dec - 1.0
    return stake * (p * b - (1.0 - p))

def kelly_fraction(p, dec):
    if pd.isna(p) or pd.isna(dec) or dec <= 1.0:
        return 0.0
    b = dec - 1.0
    f = (p * b - (1.0 - p)) / b
    return max(0.0, float(f))

def best_rows(df):
    d = df.copy()
    d['Decimal'] = d['American'].apply(american_to_decimal)
    d['_rank'] = d.groupby(['game_id', 'market', 'selection'])['Decimal'].rank(ascending=False, method='first')
    return d[d['_rank'] == 1.0].drop(columns=['_rank'])

def load_model_probs():
    if not MODEL.exists() or MODEL.stat().st_size == 0:
        return None
    mp = pd.read_csv(MODEL)
    mp.columns = [c.lower().strip() for c in mp.columns]
    need = {'game_id', 'market', 'selection', 'prob'}
    if not need.issubset(mp.columns):
        st.warning(f'model_probs.csv missing {sorted(list(need - set(mp.columns)))}; EV/Kelly disabled.')
        return None
    mp['prob'] = pd.to_numeric(mp['prob'], errors='coerce').clip(0, 1)
    return mp.dropna(subset=['prob'])

def read_lines():
    if not CSV.exists() or CSV.stat().st_size == 0:
        return pd.DataFrame()
    df = pd.read_csv(CSV)
    cols = ['pulled_ts', 'game_id', 'commence_time', 'home', 'away', 'book', 'market', 'selection', 'price_american', 'point']
    missing = [c for c in cols if c not in df.columns]
    if missing:
        st.error(f'lines_live.csv missing columns: {missing}')
        return pd.DataFrame()
    df = df.rename(columns={'price_american': 'American', 'point': 'Line/Point'})
    df['American'] = pd.to_numeric(df['American'], errors='coerce')
    df['commence_time'] = pd.to_datetime(df['commence_time'], errors='coerce')
    return df
from tools.lines_archiver import archive_lines, build_open_close
import pandas as pd
colA, colB = st.columns(2)
with colA:
    if st.button('Snapshot (archive this pull)', width='stretch'):
        out = archive_lines()
        st.success(f'Archived snapshot: {out}')
        st.cache_data.clear()
        st.rerun()
with colB:
    if st.button('Build Open/Close for today', width='stretch'):
        today = pd.Timestamp.now(tz='America/New_York').strftime('%Y-%m-%d')
        o, c = build_open_close(today)
        st.success(f'Open {o.shape}  ¬∑  Close {c.shape}')
        st.cache_data.clear()
        st.rerun()
st.sidebar.header('Filters')
team_q = st.sidebar.text_input('Team search (home/away contains)')
market = st.sidebar.selectbox('Market', ['all', 'h2h', 'spreads', 'totals'], index=0)
min_books = st.sidebar.number_input('Min # of books per selection', 1, 20, 1, 1)
st.sidebar.header('EV & Kelly')
stake_display = st.sidebar.number_input('EV display stake ($)', 1, 10000, 100, 25)
show_pos_ev = st.sidebar.toggle('Show only +EV (needs model_probs)', value=False)
min_ev_pct = st.sidebar.number_input('Min EV %', value=0.0, step=0.5)
bankroll = st.sidebar.number_input('Bankroll ($)', 0, 10000000, 1000, 50)
kelly_cap = st.sidebar.number_input('Kelly fraction cap (0..1)', 0.0, 1.0, 0.25, 0.05)
df = read_lines()
if df.empty:
    st.warning('No live odds found. Populate exports/lines_live.csv.')
    st.stop()
if team_q:
    s = team_q.strip().lower()
    df = df[df['home'].str.lower().str.contains(s) | df['away'].str.lower().str.contains(s)]
if market != 'all':
    df = df[df['market'] == market]
books = sorted(df['book'].dropna().unique().tolist())
chosen_books = st.sidebar.multiselect('Books', books, default=books)
if chosen_books:
    df = df[df['book'].isin(chosen_books)]
counts = df.groupby(['game_id', 'market', 'selection'])['book'].nunique().rename('#Books')
df = df.merge(counts, on=['game_id', 'market', 'selection'], how='left')
df = df[df['#Books'] >= int(min_books)]
mp = load_model_probs()
if mp is not None:
    df = df.merge(mp, on=['game_id', 'market', 'selection'], how='left')
    df.rename(columns={'prob': 'Model Prob'}, inplace=True)
df['Decimal'] = df['American'].apply(american_to_decimal)
df['Impl. Prob (Odds)'] = df['American'].apply(implied_prob)
if 'Model Prob' in df.columns:
    df['EV %'] = df.apply(lambda r: ev_percent(r['Model Prob'], r['Decimal']), axis=1)
    df[f'EV @ ${stake_display}'] = df.apply(lambda r: ev_dollars(r.get('Model Prob'), r['Decimal'], stake_display), axis=1)
    df['Kelly f'] = df.apply(lambda r: kelly_fraction(r.get('Model Prob'), r['Decimal']), axis=1)
    df['Kelly stake ($)'] = (df['Kelly f'].clip(lower=0) * kelly_cap * bankroll).round(2)
else:
    df['EV %'] = df[f'EV @ ${stake_display}'] = df['Kelly f'] = df['Kelly stake ($)'] = np.nan
if show_pos_ev and 'EV %' in df.columns:
    df = df[df['EV %'].fillna(-999) >= float(min_ev_pct)]
base_cols = ['commence_time', 'home', 'away', 'market', 'selection', 'book', 'American', 'Line/Point', 'Decimal', 'Impl. Prob (Odds)', '#Books']
ev_cols = ['Model Prob', 'EV %', f'EV @ ${stake_display}', 'Kelly f', 'Kelly stake ($)'] if 'Model Prob' in df.columns else []
show_cols = [c for c in base_cols + ev_cols if c in df.columns]
tab_best, tab_all = st.tabs(['Quick Odds Shop (Best Price)', 'All Quotes'])
with tab_best:
    best = best_rows(df)
    st.caption('Best price per (game_id, market, selection).')
    st.dataframe(best[show_cols], hide_index=True, width='stretch')
    st.subheader('Pick rows to add to Bet Slip')
    best = best.assign(_id=best['game_id'] + '|' + best['market'] + '|' + best['selection'] + '|' + best['book'].astype(str))
    labels = (best['home'] + ' @ ' + best['away'] + ' ‚Ä¢ ' + best['market'] + ' ‚Ä¢ ' + best['selection'] + ' ‚Ä¢ ' + best['book']).tolist()
    choice_map = dict(zip(labels, best['_id']))
    picked = st.multiselect('Choose one or more', labels, key='ls_picklist')
    if 'bet_slip' not in st.session_state:
        st.session_state['bet_slip'] = []
    if st.button('‚ûï Add selected to Bet Slip', disabled=len(picked) == 0):
        ids = {choice_map[lbl] for lbl in picked}
        add = best[best['_id'].isin(ids)]
        to_add = add.assign(stake=np.where(pd.notna(add.get('Kelly stake ($)')), add['Kelly stake ($)'], 0.0))
        st.session_state['bet_slip'].extend(to_add.to_dict('records'))
        st.success(f'Added {len(to_add)} selections.')
with tab_all:
    st.dataframe(df[show_cols], hide_index=True, width='stretch')
st.markdown('---')
st.header('üßæ Bet Slip')
slip = pd.DataFrame(st.session_state.get('bet_slip', []))
if slip.empty:
    st.info('Bet Slip is empty. Use the Best tab to add picks.')
else:
    display_cols = [c for c in ['home', 'away', 'market', 'selection', 'book', 'American', 'Decimal', 'Model Prob', 'EV %', 'Kelly f', 'Kelly stake ($)', 'stake'] if c in slip.columns]
    st.dataframe(slip[display_cols], hide_index=True, width='stretch')
    if 'stake' in slip.columns:
        st.write(f"**Total stake:** ${float(pd.to_numeric(slip['stake'], errors='coerce').fillna(0).sum()):,.2f}")
    if st.button('üóëÔ∏è Clear Bet Slip'):
        st.session_state['bet_slip'] = []
        st.rerun()
try:
    import pandas as _ef_pd
    from pathlib import Path as _ef_Path
    _ef = locals().get('diag', None)
    if _ef:
        for _nm in ('edges_p', 'live_p', 'oc_path', 'edges_path', 'live_path', 'scores_path', 'scores_p', 'epath', 'spath', '_lines_p', '_edges_p'):
            _p = locals().get(_nm, None)
            if _p:
                try:
                    _ef.check_file(_ef_Path(str(_p)), required=False, label=_nm)
                except Exception:
                    pass
        for _dfn in ('edges', 'live', 'oc', 'scores', 'joined', 'view'):
            _df = locals().get(_dfn, None)
            try:
                if isinstance(_df, _ef_pd.DataFrame):
                    _ef.log_df(_df, _dfn)
            except Exception:
                pass
except Exception:
    pass
try:
    if 'df' in globals() and isinstance(df, pd.DataFrame):
        selectable_odds_table(df, page_key='line_shop', page_name='01_Line_Shop')
except Exception as _e:
    pass





