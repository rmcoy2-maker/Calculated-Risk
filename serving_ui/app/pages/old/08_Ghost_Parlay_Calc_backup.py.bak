# -*- coding: utf-8 -*-
# 08_Ghost_Parlay_Calc.py ‚Äî Top-N Ghost Parlay Finder (uses Line Shop live feed)

from __future__ import annotations

import os
import math
import heapq
from pathlib import Path
from _branding import setup_branding
setup_branding(__file__, subtitle="Edge Finder Betting Analytics Parlay Builder")

import numpy as np
import pandas as pd
import streamlit as st
from tools.lines_shop_io import read_latest_shop

# ---------------- Page config ----------------
st.set_page_config(page_title="Ghost Parlay Calculator", page_icon="üëª", layout="wide")
st.title("Ghost Parlay Calculator")

# Optional: manual refresh (clears cache + rerun)
if st.button("Refresh data", type="primary"):
    st.cache_data.clear()
    st.rerun()

# ---------------- Load from Line Shop ----------------
@st.cache_data(show_spinner=False)
def load_lines() -> pd.DataFrame:
    df = read_latest_shop()
    # normalize column names lower for internal use
    df = df.copy()
    df.columns = [str(c).strip().lower() for c in df.columns]
    # ensure required columns exist
    for c in ("game_id","market","side","book","odds","p_win"):
        if c not in df.columns:
            df[c] = np.nan if c in ("odds","p_win") else ""
    # if model prob not present, infer from odds
    if df["p_win"].isna().all():
        def _amer_to_p(o):
            try:
                o = float(o)
            except Exception:
                return np.nan
            return 100.0/(o+100.0) if o>0 else abs(o)/(abs(o)+100.0) if o<0 else np.nan
        df["p_win"] = df["odds"].map(_amer_to_p)
    # numeric coercions
    df["odds"]  = pd.to_numeric(df["odds"], errors="coerce")
    df["p_win"] = pd.to_numeric(df["p_win"], errors="coerce").clip(0,1)
    return df

edges = load_lines()
st.caption(f"Loaded Line Shop ¬∑ rows={len(edges):,} ¬∑ cols={len(edges.columns)}")
if edges.empty:
    st.warning("No lines found. Make sure exports/lines_shop_latest.parquet exists and has columns like: game_id, market, side, book, odds (and p_win if you have model probs).")
    st.stop()

# ---------------- Sidebar controls ----------------
st.sidebar.header("Build Controls")
max_legs      = st.sidebar.slider("Max legs (min 3)", min_value=3, max_value=10, value=4, step=1)
min_p         = st.sidebar.slider("Min leg win prob", min_value=0.30, max_value=0.80, value=0.50, step=0.01)
min_abs_odds  = st.sidebar.number_input("Min |odds|", min_value=50, max_value=10000, value=100, step=10)
limit_combos  = st.sidebar.number_input("Cap combos (0=no cap)", min_value=0, max_value=2_000_000, value=5_000, step=500)

st.sidebar.divider()
st.sidebar.header("Ranking & Filters")
min_roi_pct   = st.sidebar.number_input("Min ROI (%)", value=0.0, step=0.5)  # placeholder for future gating
min_kelly     = st.sidebar.number_input("Min Kelly", value=0.00, step=0.01)  # placeholder
show_top_n    = st.sidebar.number_input("Show top N", min_value=5, max_value=250, value=25, step=5)

# ---------------- Helpers: odds / EV ----------------
def american_to_decimal(o):
    try:
        o = float(o)
    except Exception:
        return math.nan
    if o > 0:  return 1.0 + (o/100.0)
    if o < 0:  return 1.0 + (100.0/abs(o))
    return math.nan

def parlay_ev_per_dollar(p_list, dec_list):
    """EV per $1 for a parlay: EV = P(all win)*(prod_dec-1) - (1 - P(all win))."""
    if not p_list or not dec_list:
        return math.nan
    p_all, dec_prod = 1.0, 1.0
    for p, d in zip(p_list, dec_list):
        if not (0.0 <= p <= 1.0) or not (d > 1.0):
            return math.nan
        p_all   *= p
        dec_prod *= d
    return p_all * (dec_prod - 1.0) - (1.0 - p_all)

# ---------------- Build eligible pool ----------------
pool = edges.dropna(subset=["game_id","side","book"]).copy()
pool = pool[(pool["p_win"].fillna(0) >= float(min_p)) & (pool["odds"].abs() >= float(min_abs_odds))]

# dedupe: keep best (highest decimal) per (game_id, market, side, book)
pool["dec"] = pool["odds"].map(american_to_decimal)
pool["_rk"] = pool.groupby(["game_id","market","side","book"])["dec"].rank(ascending=False, method="first")
pool = pool[pool["_rk"] == 1.0].drop(columns=["_rk"]).reset_index(drop=True)

# ---------------- Pool diagnostics ----------------
from math import comb as _comb
def _safe_comb(n: int, k: int) -> str:
    try:
        if k <= 0 or n < k:
            return "0"
        v = _comb(n, k)
        return f"{v:,}" if v < 1_000_000_000 else f"{v/1_000_000_000:.1f}B+"
    except Exception:
        return "‚Äî"

pool_n = len(pool)
est = _safe_comb(pool_n, int(max_legs))
cap_txt = ("no cap" if int(limit_combos) == 0 else f"{int(limit_combos):,}")
st.caption(f"**Pool:** {pool_n:,} legs ‚Ä¢ **Max legs:** {int(max_legs)} ‚Ä¢ **Cap combos:** {cap_txt} ‚Ä¢ **~Combos @ max:** {est}")

if pool_n == 0:
    st.warning("No legs match current sliders. Lower **Min leg win prob** or **Min |odds|**.")
    st.stop()

# ---------------- Fast Top-N search (beam / capped) ----------------
def topN_parlays(pool_df, max_legs: int, cap: int, topN: int, per_game_limit: int = 1):
    """
    Return top-N parlays by EV/$1 without brute-forcing all combos.
    pool_df must contain: ['game_id','market','side','book','odds','p_win']
    """
    if max_legs < 2:
        max_legs = 2
    if cap is None or int(cap) <= 0:
        cap = 100_000

    df = pool_df.copy()
    df["dec"] = df["odds"].map(american_to_decimal)
    df = df[pd.to_numeric(df["p_win"], errors="coerce").between(0,1)]
    df = df[pd.to_numeric(df["dec"], errors="coerce") > 1.0]
    if df.empty:
        return []

    rows = df[["game_id","market","side","book","odds","p_win","dec"]].to_dict("records")
    n = len(rows)
    if n == 0:
        return []

    rows.sort(key=lambda r: (r["p_win"]*(r["dec"]-1.0)), reverse=True)

    def ok_with_game(add_gid, used):
        return used.get(add_gid, 0) < per_game_limit

    evals = 0
    best_heap: list[tuple[float,int,dict]] = []
    idx_counter = 0

    beam = min(max(1000, cap//10), 10000)
    partials: list[tuple[float,int,list,int,dict,float,float]] = []

    for i, r in enumerate(rows[:beam]):
        p = r["p_win"]; d = r["dec"]
        ev = parlay_ev_per_dollar([p], [d])
        partials.append((ev, i, [i], 1, {r["game_id"]:1}, p, d))
        idx_counter += 1
        heapq.heappush(best_heap, (ev, idx_counter, {"legs":[i], "n_legs":1, "p_all":p, "dec":d, "ev_per_$1":ev}))
        if len(best_heap) > topN:
            heapq.heappop(best_heap)

    for L in range(2, max_legs+1):
        next_partials = []
        partials.sort(key=lambda t: t[0], reverse=True)
        partials = partials[:beam]

        for ev_curr, last_idx, idxs, nlegs, gid_count, p_all, dec_prod in partials:
            for j in range(last_idx+1, n):
                rj = rows[j]
                gid = rj["game_id"]
                if not ok_with_game(gid, gid_count):
                    continue
                new_idxs = idxs + [j]
                new_gid_count = dict(gid_count); new_gid_count[gid] = new_gid_count.get(gid,0)+1
                new_p_all = p_all * rj["p_win"]
                new_dec   = dec_prod * rj["dec"]
                ev = parlay_ev_per_dollar([rows[k]["p_win"] for k in new_idxs],
                                          [rows[k]["dec"]   for k in new_idxs])
                evals += 1

                next_partials.append((ev, j, new_idxs, nlegs+1, new_gid_count, new_p_all, new_dec))

                idx_counter += 1
                heapq.heappush(best_heap, (ev, idx_counter, {
                    "legs": new_idxs, "n_legs": nlegs+1, "p_all": new_p_all, "dec": new_dec, "ev_per_$1": ev
                }))
                if len(best_heap) > topN:
                    heapq.heappop(best_heap)

                if evals >= cap:
                    out = [heapq.heappop(best_heap)[2] for _ in range(len(best_heap))]
                    out.reverse()
                    for it in out:
                        it["legs"] = [rows[k] for k in it["legs"]]
                    return out

        partials = next_partials
        if not partials:
            break

    out = [heapq.heappop(best_heap)[2] for _ in range(len(best_heap))]
    out.reverse()
    for it in out:
        it["legs"] = [rows[k] for k in it["legs"]]
    return out

# ---------------- Generate button ----------------
go = st.button("Generate Ghost Parlays", type="secondary", disabled=False)
if not go:
    st.info("Build some parlays first with **Generate Ghost Parlays**.")
    st.stop()

with st.spinner("Searching best parlays‚Ä¶"):
    res = topN_parlays(
        pool_df = pool[["game_id","market","side","book","odds","p_win"]].copy(),
        max_legs = int(max_legs),
        cap = int(limit_combos),
        topN = int(show_top_n),
        per_game_limit = 1,
    )

if not res:
    st.warning("No parlays found at current filters.")
    st.stop()

# ---------------- Flatten & display ----------------
rows_out = []
for r in res:
    legs = r["legs"]
    title = " + ".join([f'{l["side"]} ({l["book"]} {int(l["odds"]):+d})' for l in legs])
    rows_out.append({
        "n_legs": r["n_legs"],
        "EV/$1": round(float(r["ev_per_$1"]), 4) if pd.notna(r["ev_per_$1"]) else np.nan,
        "Parlay Prob": round(float(r["p_all"]), 6) if pd.notna(r["p_all"]) else np.nan,
        "Parlay Dec": round(float(r["dec"]), 4) if pd.notna(r["dec"]) else np.nan,
        "Title": title,
        "Legs": legs,
    })

out_df = pd.DataFrame(rows_out).sort_values(["EV/$1","Parlay Prob"], ascending=[False, False]).head(int(show_top_n))

st.subheader(f"Top {len(out_df)} Parlays")
st.dataframe(out_df[["n_legs","EV/$1","Parlay Prob","Parlay Dec","Title"]],
             use_container_width=True, hide_index=True, height=560)

csv = out_df.to_csv(index=False).encode("utf-8")
st.download_button("‚¨áÔ∏è Download Top Parlays (CSV)", data=csv, file_name="ghost_parlays_top.csv", mime="text/csv")

with st.expander("Show raw legs for top parlays"):
    st.write(out_df[["n_legs","EV/$1","Parlay Prob","Parlay Dec","Legs"]])

