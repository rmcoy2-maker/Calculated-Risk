# -*- coding: utf-8 -*-
from __future__ import annotations
# --- auto-added: newest-first patch ---
from __future__ import annotations
try:
    # Preferred absolute import (when 'app' is a proper package)
    from app.utils.newest_first_patch import apply_newest_first_patch as __nfp_apply
except Exception:
    try:
        # Fallback if pages are executed such that relative path works
        from utils.newest_first_patch import apply_newest_first_patch as __nfp_apply
    except Exception:
        # Final no-op guard
        def __nfp_apply(_): 
            return
import streamlit as st  # ensure alias available
__nfp_apply(st)
# --- end auto-added ---
from app.bootstrap import bootstrap_paths
bootstrap_paths()


# Backtest — feature-rich page with seasons/weeks controls and run buttons







from pathlib import Path


import re


import subprocess


import sys


import os


import pandas as pd


import numpy as np


import streamlit as st





# ---------------------------------------------------------------------


# Paths & constants


# ---------------------------------------------------------------------


REPO_ROOT  = Path(__file__).resolve().parents[3]  # .../edge-finder


EXPORTS    = REPO_ROOT / "exports"


EDGES_CSV  = EXPORTS / "edges.csv"





MIN_SEASON = 1966


MAX_SEASON_FALLBACK = 2025


WEEKS = list(range(1, 23))  # 1..22





# ---------------------------------------------------------------------


# Utilities


# ---------------------------------------------------------------------


def _read_edges() -> pd.DataFrame:


    """Read edges.csv robustly; return normalized DataFrame."""


    if not EDGES_CSV.exists():


        return pd.DataFrame()





    # Try BOM first, fall back to defaults, all guarded


    for kw in ({"encoding": "utf-8-sig"}, {}, {"engine": "python"}):


        try:


            df = pd.read_csv(EDGES_CSV, **kw)


            break


        except Exception:


            df = pd.DataFrame()


    if df.empty:


        return df





    # Normalize columns


    df = df.copy()


    df.columns = [str(c).strip().lower() for c in df.columns]





    # Timestamp column for sorting/plots


    df["sort_ts"] = pd.to_datetime(df.get("ts"), errors="coerce")





    # Ensure expected numeric columns exist


    for c in ("stake", "profit", "edge"):


        if c not in df.columns:


            df[c] = 0





    # Try to ensure season/week exist; derive if missing


    if "season" not in df.columns:


        # Prefer season from ts year (NFL seasons are typically the year part of the schedule)


        season_from_ts = df["sort_ts"].dt.year


        # If game_id has a YYYY-MM-DD or *_YYYY-MM-DD* style, prefer that year


        season_from_gid = pd.Series(np.nan, index=df.index)


        if "game_id" in df.columns:


            season_from_gid = (


                df["game_id"]


                .astype(str)


                .str.extract(r"(\d{4})-\d{2}-\d{2}", expand=False)


                .astype("float")


            )


        season = season_from_gid.fillna(season_from_ts).fillna(MAX_SEASON_FALLBACK).astype(int)


        df["season"] = season





    if "week" not in df.columns:


        # Try to extract week from columns named like 'week' first (covered), otherwise parse from game_id


        week_from_gid = pd.Series(np.nan, index=df.index)


        if "game_id" in df.columns:


            # common shapes: "..._Wk05..." or "..._week_5..." or "..._wk_5..."


            w = df["game_id"].astype(str).str.extract(r"[Ww](?:eek)?[_-]?(\d{1,2})", expand=False)


            week_from_gid = pd.to_numeric(w, errors="coerce")


        df["week"] = week_from_gid





    # Coerce final dtypes


    df["season"] = pd.to_numeric(df["season"], errors="coerce")


    df["week"]   = pd.to_numeric(df["week"],   errors="coerce")





    return df





def _filter_edges(df: pd.DataFrame, seasons: list[int] | None, weeks: list[int] | None) -> pd.DataFrame:


    """Apply season/week filters when provided."""


    if df.empty:


        return df


    out = df


    if seasons:


        out = out[out["season"].isin(seasons)]


    if weeks:


        out = out[out["week"].isin(weeks)]


    return out





def _summary(df: pd.DataFrame) -> dict:


    if df.empty:


        return dict(n=0, stake=0.0, profit=0.0, roi=None)


    stake_sum  = pd.to_numeric(df.get("stake", 0),  errors="coerce").fillna(0).sum()


    profit_sum = pd.to_numeric(df.get("profit", 0), errors="coerce").fillna(0).sum()


    roi = (profit_sum / stake_sum) if stake_sum > 0 else None


    return dict(n=len(df), stake=stake_sum, profit=profit_sum, roi=roi)





def _equity(df: pd.DataFrame, start: float = 100.0) -> pd.DataFrame:


    if df.empty:


        return pd.DataFrame({"ts": [], "equity": []}).set_index("ts")


    p = pd.to_numeric(df.get("profit", 0), errors="coerce").fillna(0)


    eq = start + p.cumsum()


    out = pd.DataFrame({"ts": df["sort_ts"], "equity": eq})


    out.set_index("ts", inplace=True)


    return out





def _seasons_available(df: pd.DataFrame) -> list[int]:


    if df.empty or "season" not in df.columns:


        return list(range(MIN_SEASON, MAX_SEASON_FALLBACK + 1))


    s = pd.to_numeric(df["season"], errors="coerce").dropna().astype(int)


    if s.empty:


        return list(range(MIN_SEASON, MAX_SEASON_FALLBACK + 1))


    lo, hi = max(MIN_SEASON, int(s.min())), int(s.max())


    # pad to allow full-range selection UI


    hi = max(hi, MAX_SEASON_FALLBACK)


    return list(range(lo, hi + 1))





def _download_csv(df: pd.DataFrame) -> bytes:


    return df.to_csv(index=False).encode("utf-8-sig")





# ---------------------------------------------------------------------


# “Newest first” toggle helper (local, no global monkey-patch)


# ---------------------------------------------------------------------


def _sort_newest(df: pd.DataFrame, newest_first: bool = True, time_col="sort_ts") -> pd.DataFrame:


    if df.empty or time_col not in df.columns:


        return df


    df2 = df.copy()


    df2[time_col] = pd.to_datetime(df2[time_col], errors="coerce")


    return df2.sort_values(time_col, ascending=not newest_first, na_position="last")





# ---------------------------------------------------------------------


# Page UI


# ---------------------------------------------------------------------


st.subheader("Backtest — Summary")





# Load once


edges = _read_edges()





# Seasons & weeks selector row


avail_seasons = _seasons_available(edges)


default_max   = max(avail_seasons) if avail_seasons else MAX_SEASON_FALLBACK





with st.container():


    c1, c2, c3, c4 = st.columns([2, 1, 2, 1])





    # Seasons


    with c1:


        st.caption("Seasons")


        # Use a multiselect to allow ranges + "All"


        seasons_all = ["All"] + [str(y) for y in avail_seasons]


        # Remember last choice


        if "bk_seasons" not in st.session_state:


            st.session_state["bk_seasons"] = ["All"]


        seasons_sel = st.multiselect(


            "Select seasons", seasons_all, default=st.session_state["bk_seasons"], key="ui_seasons"


        )


        # Normalize selection


        if "All" in seasons_sel:


            seasons_pick = [int(y) for y in avail_seasons]


        else:


            seasons_pick = [int(y) for y in seasons_sel if re.fullmatch(r"\d{4}", y or "")]





    with c2:


        st.caption("Quick seasons")


        if st.button("All seasons"):


            st.session_state["bk_seasons"] = ["All"]


            seasons_pick = [int(y) for y in avail_seasons]


        if st.button("Clear seasons"):


            st.session_state["bk_seasons"] = []


            seasons_pick = []





    # Weeks


    with c3:


        st.caption("Weeks")


        week_labels = [str(w) for w in WEEKS]


        if "bk_weeks" not in st.session_state:


            st.session_state["bk_weeks"] = week_labels  # default to all weeks


        weeks_sel = st.multiselect(


            "Select weeks (1–22)", week_labels, default=st.session_state["bk_weeks"], key="ui_weeks"


        )


        weeks_pick = [int(x) for x in weeks_sel if x.isdigit()]





    with c4:


        st.caption("Quick weeks")


        if st.button("All weeks"):


            st.session_state["bk_weeks"] = [str(w) for w in WEEKS]


            weeks_pick = list(WEEKS)


        if st.button("Clear weeks"):


            st.session_state["bk_weeks"] = []


            weeks_pick = []





# Controls row (bankroll, sort, run)


with st.container():


    c1, c2, c3 = st.columns([2, 2, 1])


    with c1:


        start_bankroll = st.number_input("Starting bankroll (units)", 0.0, 1e9, 100.0, 1.0, key="bk_start")


    with c2:


        newest_first = st.toggle("Newest first", value=True, help="Sort by timestamp: newest rows first")


    with c3:


        run_bt = st.button("Run Backtest", type="primary")





# Optional ETL runner (kept collapsed)


with st.expander("Diagnostics / Run ETL (optional)", expanded=False):


    st.caption(


        "If your ETL modules live under core_engine, running them as modules avoids relative import errors."


    )


    etl_col1, etl_col2 = st.columns([1, 3])


    with etl_col1:


        do_lines = st.button("Run: python -m core_engine.etl.pull_lines")


        do_stats = st.button("Run: python -m core_engine.etl.pull_stats")


    with etl_col2:


        etl_out = st.empty()





    def _run_module(mod: str):


        # ensure PYTHONPATH includes repo root so 'core_engine' package resolves


        env = os.environ.copy()


        env["PYTHONPATH"] = str(REPO_ROOT)


        cmd = [sys.executable, "-m", mod]


        try:


            proc = subprocess.run(cmd, cwd=str(REPO_ROOT), env=env, capture_output=True, text=True, timeout=180)


            text = (proc.stdout or "") + "\n" + (proc.stderr or "")


            code = proc.returncode


        except Exception as e:


            text = f"Exception: {e}"


            code = -1


        etl_out.code(text.strip() or "(no output)")


        st.write(f"ETL exited with code **{code}**")





    if do_lines:


        _run_module("core_engine.etl.pull_lines")


    if do_stats:


        _run_module("core_engine.etl.pull_stats")





# Apply filters


filtered = _filter_edges(edges, seasons_pick, weeks_pick)


filtered = _sort_newest(filtered, newest_first=newest_first, time_col="sort_ts")





# Summary metrics


S = _summary(filtered)


m1, m2, m3 = st.columns(3)


m1.metric("Edges", f"{S['n']:,}")


m2.metric("Stake Σ", f"{S['stake']:,.2f}")


m3.metric("ROI", "-" if S["roi"] is None else f"{S['roi']*100:.1f}%")





# Equity curve


st.subheader("Equity curve")


if filtered.empty:


    st.info("No edges match current filters.")


else:


    st.line_chart(_equity(filtered, start=start_bankroll), y="equity")





# Table + download


st.subheader("Edges preview")


st.dataframe(filtered, use_container_width=True, hide_index=True)





dl = _download_csv(filtered if not filtered.empty else edges)


st.download_button(


    "Download filtered picks.csv",


    data=dl,


    file_name="picks_filtered.csv",


    mime="text/csv",


)



