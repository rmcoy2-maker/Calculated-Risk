# -*- coding: utf-8 -*-
# app/pages/03_Backtest.py ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¾Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¾ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¡ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¡ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¾Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¡ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¡ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¦ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¡ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¡ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¡ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¾Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¡ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¡ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¡ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¡ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¡ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â v4: season fallback + never-drop filters
from __future__ import annotations

import datetime as dt
from pathlib import Path
from typing import Dict, List, Tuple

import numpy as np
import pandas as pd
import streamlit as st
import contextlib
import contextlib

# ---------------- Paths ----------------
_REPO_ROOT = Path(__file__).resolve().parents[3]  # C:\Projects\edge-finder
EXPORTS = _REPO_ROOT / "exports"
EXPORTS.mkdir(parents=True, exist_ok=True)

# ---------------- Helpers ----------------
def _read_csv_safe(path: Path) -> pd.DataFrame:
    try:
        if not path.exists() or path.stat().st_size == 0:
            return pd.DataFrame()
        return pd.read_csv(path)
    except Exception:
        return pd.DataFrame()

def american_to_decimal(odds: float) -> float:
    o = float(odds)
    return 1 + (o/100.0 if o > 0 else 100.0/abs(o))

def implied_prob_from_american(am: float) -> float:
    am = float(am)
    return 100.0 / (am + 100.0) if am >= 0 else abs(am) / (abs(am) + 100.0)

def kelly_fraction(p: float, american_odds: float, fraction: float = 0.5) -> float:
    try:
        p = float(p)
        b = american_to_decimal(float(american_odds)) - 1.0
        q = 1.0 - p
        if b <= 0 or not (0.0 < p < 1.0):
            return 0.0
        f = (b * p - q) / b
        return max(0.0, min(1.0, f * float(fraction)))
    except Exception:
        return 0.0

def settle_row(row) -> tuple[float, bool]:
    try:
        stake = float((row.get("stake", 0) if hasattr(row, "get") else row["stake"]) or 0)
        odds  = float((row.get("odds", 0)  if hasattr(row, "get") else row["odds"])  or 0)
        res   = (row.get("result", "") if hasattr(row, "get") else row.get("result", ""))
        res   = str(res or "").lower()
        dec   = american_to_decimal(odds)
        if res in ("win","won","w"):   return stake * (dec - 1.0), True
        if res in ("lose","lost","l"): return -stake, True
        if res in ("push","void","cancel","canceled","cancelled"): return 0.0, True
        return 0.0, False
    except Exception:
        return 0.0, False

def normalize_bets(df: pd.DataFrame, source_tag: str) -> pd.DataFrame:
    if df is None or df.empty:
        return pd.DataFrame()
    df = df.copy()
    df.columns = [c.strip().lower() for c in df.columns]
    keep = ["ts","sport","league","game_id","season","week","market","ref","side","line","odds","p_win","ev","result","stake","placed_at"]
    for c in keep:
        if c not in df.columns:
            df[c] = None
    ts = pd.to_datetime(df["placed_at"], errors="coerce")
    ts = ts.where(ts.notna(), pd.to_datetime(df["ts"], errors="coerce"))
    df["placed_at"] = ts
    df["odds"]  = pd.to_numeric(df["odds"], errors="coerce")
    df["stake"] = pd.to_numeric(df["stake"], errors="coerce").fillna(0.0)
    df["p_win"] = pd.to_numeric(df["p_win"], errors="coerce")
    df["src"]   = source_tag
    return df

_MARKET_GROUPS = {
    "Moneyline":   ["ml","moneyline","money line","money-line"],
    "Spread":      ["spread","ats","handicap","point spread"],
    "Total (O/U)": ["total","totals","o/u","over/under","ou"],
    "Props":       ["prop","props","player","passing","rushing","receiving","td","interception","tackles","sacks"],
    "Parlay":      ["parlay"],
}
def classify_market(val: str) -> str:
    t = str(val or "").lower()
    for group, kws in _MARKET_GROUPS.items():
        if any(kw in t for kw in kws):
            return group
    if t == "total":
        return "Total (O/U)"
    return "Other"

def bankroll_curve(df: pd.DataFrame, bankroll_start: float = 100.0) -> pd.DataFrame:
    if df is None or df.empty:
        return pd.DataFrame(columns=["placed_at","bankroll","running_max","drawdown"])
    x = df.sort_values("placed_at").copy()
    x["pnl_realized"] = pd.to_numeric(x.get("pnl", 0), errors="coerce").fillna(0.0)
    x["cum_pnl"] = x["pnl_realized"].cumsum()
    x["bankroll"] = bankroll_start + x["cum_pnl"]
    x["running_max"] = x["bankroll"].cummax()
    x["drawdown"] = x["bankroll"] - x["running_max"]
    return x[["placed_at","bankroll","running_max","drawdown"]]

def summarize(df: pd.DataFrame, curve: pd.DataFrame) -> pd.DataFrame:
    if "result" not in df.columns:
        df = df.copy(); df["result"] = np.nan
    total_staked = float(pd.to_numeric(df.get("stake", pd.Series(dtype=float)), errors="coerce").fillna(0).sum())
    realized_mask = df.get("result", pd.Series(dtype=str)).astype(str).str.lower().isin(
        ["win","won","w","lose","lost","l","push","void","cancel","canceled","cancelled"]
    )
    realized = df[realized_mask].copy()
    wins   = realized["result"].astype(str).str.lower().isin(["win","won","w"]).sum()
    losses = realized["result"].astype(str).str.lower().isin(["lose","lost","l"]).sum()
    pushes = realized["result"].astype(str).str.lower().isin(["push","void","cancel","canceled","cancelled"]).sum()
    settled = len(realized)
    realized_pnl = float(pd.to_numeric(realized.get("pnl", 0), errors="coerce").fillna(0).sum())
    if realized_pnl == 0 and settled:
        total = 0.0
        for _, r in realized.iterrows():
            pnl, _ = settle_row(r if r.get("stake") not in (None, 0) else {"stake": r.get("stake_sim", 0.0), "odds": r.get("odds"), "result": r.get("result")})
            total += pnl
        realized_pnl = total
    roi      = (realized_pnl / total_staked) if total_staked else np.nan
    avg_odds = pd.to_numeric(realized.get("odds", pd.Series(dtype=float)), errors="coerce").mean()
    max_dd   = float(curve["drawdown"].min()) if not curve.empty else 0.0
    return pd.DataFrame([{
        "bets": len(df), "settled": int(settled), "wins": int(wins), "losses": int(losses), "pushes": int(pushes),
        "staked_units": round(total_staked, 2), "realized_pnl": round(realized_pnl, 2),
        "roi": round(roi, 4) if pd.notna(roi) else np.nan,
        "avg_odds": round(float(avg_odds), 2) if pd.notna(avg_odds) else np.nan,
        "max_drawdown": round(max_dd, 2),
    }])

def _infer_season_week(df: pd.DataFrame) -> pd.DataFrame:
    df = df.copy()
    ts = pd.to_datetime(df.get("placed_at").fillna(df.get("ts")), errors="coerce", utc=True)

    s = pd.to_numeric(df.get("season"), errors="coerce")
    df["season"] = s
    if ts is not None:
        df.loc[df["season"].isna(), "season"] = ts.dt.year
    df["season"] = df["season"].astype("Int64")

    w = pd.to_numeric(df.get("week"), errors="coerce")
    if w is None or (hasattr(w, "isna") and w.isna().all()):
        if ts is not None:
            w = ts.dt.isocalendar().week.astype("Int64")
    else:
        w = w.astype("Int64")
    df["week"] = w
    return df

def _preview_seasons_weeks() -> Tuple[List[str], Dict[str, List[int]]]:
    current = dt.datetime.utcnow().year
    seasons = [str(y) for y in range(1966, current + 1)]
    weeks_by_season: Dict[str, List[int]] = {s: list(range(1, 23)) for s in seasons}
    return seasons, weeks_by_season

# --- staking helpers (inserted) ---
import math

def _american_to_decimal(odds):
    """Convert American odds to decimal. Returns NaN on failure."""
    try:
        o = float(odds)
    except Exception:
        return float('nan')
    if o >= 100:
        return 1.0 + (o/100.0)
    if o <= -100:
        return 1.0 + (100.0/abs(o))
    return float('nan')

def apply_staking_policy(row, bankroll_now, policy,
                         unit_size=None, pct_bank=None,
                         kelly_frac=None, kelly_cap=None):
    """
    Decide stake for a single pick.

    policy:
      - 'flat' / 'units'       -> fixed dollar 'unit_size'
      - 'percent_bankroll'     -> pct of bankroll_now via 'pct_bank' (e.g., 0.01 for 1%)
      - 'kelly' / 'kelly_capped' -> Kelly fraction using row['p_win'] and row['odds']

    Args:
        row: dict-like with at least 'p_win' (0..1) and 'odds' (American, e.g., -110, +150)
        bankroll_now: current bankroll (float)
        unit_size: dollars when policy is flat
        pct_bank: fraction (0..1) when percent bankroll policy
        kelly_frac: fraction of Kelly (e.g., 0.5 for half-Kelly)
        kelly_cap: optional dollar cap on stake for Kelly variants
    """
    # Sanity
    try:
        bk = float(bankroll_now)
    except Exception:
        bk = 0.0

    pol = str(policy or '').lower().strip()
    stake = 0.0

    if pol in ('flat','units','unit','flat_units'):
        try:
            stake = float(unit_size or 0.0)
        except Exception:
            stake = 0.0
        return max(stake, 0.0)

    if pol in ('percent_bankroll','pct_bank','percent'):
        try:
            frac = float(pct_bank or 0.0)
        except Exception:
            frac = 0.0
        return max(frac * bk, 0.0)

    # Kelly variants
    # p_win
    p = row.get('p_win', None)
    try:
        p = float(p)
    except Exception:
        p = None
    if p is None or not (0.0 <= p <= 1.0):
        # fall back to flat unit if provided
        return float(unit_size or 0.0) if unit_size is not None else 0.0

    # odds -> decimal
    b = _american_to_decimal(row.get('odds', None)) - 1.0
    if b != b:  # NaN
        return float(unit_size or 0.0) if unit_size is not None else 0.0
    if b == 0.0:
        return 0.0

    q = 1.0 - p
    f_star = (b*p - q) / b  # Kelly fraction of bankroll
    if f_star < 0:
        f_star = 0.0

    try:
        frac = float(kelly_frac or 1.0)
    except Exception:
        frac = 1.0
    stake = frac * f_star * bk

    if kelly_cap is not None:
        try:
            cap = float(kelly_cap)
            stake = min(stake, cap)
        except Exception:
            pass

    return max(stake, 0.0)
# --- end staking helpers ---
def apply_policy(df,
                 policy: str,
                 bankroll_start: float = 1000.0,
                 unit_size: float = 1.0,
                 kelly_frac: float = 1.0,
                 pct_bank: float = 0.01,
                 kelly_cap: float | None = None):
    """
    Simulate staking over time. Returns a copy with computed columns:
      - stake_calc: stake placed on the row
      - bankroll_after: bankroll right after settlement (or after placement if still open)
    Logic:
      * Deduct stake at placement.
      * If the bet is 'closed' (won/lost/push/settled/closed/graded) and 'profit' exists,
        add back stake + profit (profit is net-of-stake).
    """
    import numpy as np
    import pandas as pd

    if df is None or len(df) == 0:
        return pd.DataFrame()

    out = df.copy()
    # Normalize key columns
    out.rename(columns={c: c.lower() for c in out.columns}, inplace=True)
    if "placed_at" in out.columns:
        out["placed_at"] = pd.to_datetime(out["placed_at"], errors="coerce")
        out.sort_values("placed_at", inplace=True)

    # Ensure numeric
    for col in ("stake","profit","payout","odds","p_win"):
        if col in out.columns:
            out[col] = pd.to_numeric(out[col], errors="coerce")

    stakes = []
    bankrolls = []

    bankroll_now = float(bankroll_start)

    CLOSED = {"won","lost","push","settled","closed","graded"}

    # Iterate rows
    for _, r in out.iterrows():
        rdict = r.to_dict()

        # Decide stake per policy
        stake = apply_staking_policy(
            rdict,
            bankroll_now,
            policy,
            unit_size=unit_size,
            pct_bank=pct_bank,
            kelly_frac=kelly_frac,
            kelly_cap=kelly_cap
        )

        # Place stake
        stake = float(stake) if stake is not None else 0.0
        if stake < 0:
            stake = 0.0
        bankroll_now -= stake

        # If the bet is closed and we have profit, settle it
        status = str(rdict.get("status","")).lower()
        profit = rdict.get("profit", np.nan)
        if status in CLOSED and pd.notna(profit):
            # profit is (payout - stake); after deducting stake, add stake + profit
            bankroll_now += (stake + float(profit))

        stakes.append(stake)
        bankrolls.append(bankroll_now)

    out["stake_calc"] = stakes
    out["bankroll_after"] = bankrolls
    return out
def _max_drawdown(equity):
    peak = equity.cummax()
    dd = equity - peak
    max_dd = dd.min()
    in_dd = equity < peak
    longest = 0
    current = 0
    for v in in_dd:
        if v: current += 1
        else:
            longest = max(longest, current)
            current = 0
    longest = max(longest, current)
    return float(max_dd), int(longest)

def _brier(prob, result):
    m = (~prob.isna())
    if m.sum() == 0: return None
    return float(np.mean((prob[m] - result[m])**2))

def _logloss(prob, result, eps=1e-12):
    m = (~prob.isna())
    if m.sum() == 0: return None
    p = prob[m].clip(eps, 1-eps)
    y = result[m]
    ll = -(y*np.log(p) + (1-y)*np.log(1-p)).mean()
    return float(ll)

def compute_metrics(df):
    if df.empty: return {}
    bets = len(df)
    pushes = int((df["result"]=="push").sum()) if "result" in df else 0
    wins   = int((df["result"]=="win").sum())  if "result" in df else None
    losses = int((df["result"]=="lose").sum()) if "result" in df else None
    staked = float(df["stake_sim"].sum()) if "stake_sim" in df else 0.0
    pnl    = float(df["pnl"].sum())       if "pnl" in df else 0.0
    roi    = (pnl / staked) if staked else 0.0
    winrate = (wins / max(1,(wins or 0)+(losses or 0))) if wins is not None and losses is not None else None
    gross_win  = float(df.loc[df["pnl"]>0, "pnl"].sum()) if "pnl" in df else 0.0
    gross_loss = float(-df.loc[df["pnl"]<0, "pnl"].sum()) if "pnl" in df else 0.0
    profit_factor = (gross_win / gross_loss) if gross_loss>0 else None
    avg_odds = float(df["odds"].astype(float).mean()) if "odds" in df else None
    equity = (df["pnl"].cumsum())
    max_dd, dd_len = _max_drawdown(equity.fillna(0.0))
    y = df["result"].map({"win":1,"lose":0}) if "result" in df else pd.Series(index=df.index, dtype=float)
    brier = _brier(df.get("p_win", pd.Series(index=df.index, dtype=float)).astype(float), y.astype(float)) if "p_win" in df else None
    logloss = _logloss(df.get("p_win", pd.Series(index=df.index, dtype=float)).astype(float), y.astype(float)) if "p_win" in df else None
    by_market = None
    if "market" in df:
        by_market = (df.assign(win=(df["result"]=="win").astype(int),
                               loss=(df["result"]=="lose").astype(int))
          .groupby("market").agg(bets=("market","size"),
                                 wins=("win","sum"),
                                 losses=("loss","sum"),
                                 staked=("stake_sim","sum"),
                                 pnl=("pnl","sum"))
          .assign(roi=lambda x: x["pnl"]/x["staked"].replace(0,np.nan))
          .reset_index())
    return {
        "bets": bets, "wins": wins, "losses": losses, "pushes": pushes,
        "staked_units": staked, "realized_pnl": pnl, "roi": roi,
        "win_rate": winrate, "profit_factor": profit_factor,
        "avg_odds": avg_odds, "max_drawdown": max_dd, "dd_bars": dd_len,
        "brier": brier, "logloss": logloss, "by_market": by_market,
    }

def render_metrics(metrics):
    c1,c2,c3,c4,c5 = st.columns(5)
    with c1: st.metric("Bets", metrics.get("bets",0))
    with c2: st.metric("Win rate", f"{metrics['win_rate']*100:.1f}%" if metrics.get("win_rate") is not None else "ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â")
    with c3: st.metric("ROI", f"{metrics['roi']*100:.1f}%" if metrics.get("roi") is not None else "ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â")
    with c4: st.metric("Profit Factor", f"{metrics['profit_factor']:.2f}" if metrics.get("profit_factor") else "ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â")
    with c5: st.metric("Max DD (u)", f"{metrics['max_drawdown']:.2f}")
    c6,c7 = st.columns(2)
    with c6: st.metric("Brier", f"{metrics['brier']:.4f}" if metrics.get("brier") is not None else "ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â")
    with c7: st.metric("Log loss", f"{metrics['logloss']:.4f}" if metrics.get("logloss") is not None else "ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â")
    if isinstance(metrics.get("by_market"), pd.DataFrame) and not metrics["by_market"].empty:
        st.subheader("By market")
        st.dataframe(metrics["by_market"])




