# -*- coding: utf-8 -*-
# app/pages/03_Backtest.py ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â v4: season fallback + never-drop filters
from __future__ import annotations

import datetime as dt
from pathlib import Path
from typing import Dict, List, Tuple

import numpy as np
import pandas as pd
import streamlit as st

# ---------------- Paths ----------------
_REPO_ROOT = Path(__file__).resolve().parents[3]  # C:\Projects\edge-finder
EXPORTS = _REPO_ROOT / "exports"
EXPORTS.mkdir(parents=True, exist_ok=True)

# ---------------- Helpers ----------------
def _read_csv_safe(path: Path) -> pd.DataFrame:
    try:
        if not path.exists() or path.stat().st_size == 0:
            return pd.DataFrame()
        return pd.read_csv(path)
    except Exception:
        return pd.DataFrame()

def american_to_decimal(odds: float) -> float:
    o = float(odds)
    return 1 + (o/100.0 if o > 0 else 100.0/abs(o))

def implied_prob_from_american(am: float) -> float:
    am = float(am)
    return 100.0 / (am + 100.0) if am >= 0 else abs(am) / (abs(am) + 100.0)

def kelly_fraction(p: float, american_odds: float, fraction: float = 0.5) -> float:
    try:
        p = float(p)
        b = american_to_decimal(float(american_odds)) - 1.0
        q = 1.0 - p
        if b <= 0 or not (0.0 < p < 1.0):
            return 0.0
        f = (b * p - q) / b
        return max(0.0, min(1.0, f * float(fraction)))
    except Exception:
        return 0.0

def settle_row(row) -> tuple[float, bool]:
    try:
        stake = float((row.get("stake", 0) if hasattr(row, "get") else row["stake"]) or 0)
        odds  = float((row.get("odds", 0)  if hasattr(row, "get") else row["odds"])  or 0)
        res   = (row.get("result", "") if hasattr(row, "get") else row.get("result", ""))
        res   = str(res or "").lower()
        dec   = american_to_decimal(odds)
        if res in ("win","won","w"):   return stake * (dec - 1.0), True
        if res in ("lose","lost","l"): return -stake, True
        if res in ("push","void","cancel","canceled","cancelled"): return 0.0, True
        return 0.0, False
    except Exception:
        return 0.0, False

def normalize_bets(df: pd.DataFrame, source_tag: str) -> pd.DataFrame:
    if df is None or df.empty:
        return pd.DataFrame()
    df = df.copy()
    df.columns = [c.strip().lower() for c in df.columns]
    keep = ["ts","sport","league","game_id","season","week","market","ref","side","line","odds","p_win","ev","result","stake","placed_at"]
    for c in keep:
        if c not in df.columns:
            df[c] = None
    ts = pd.to_datetime(df["placed_at"], errors="coerce")
    ts = ts.where(ts.notna(), pd.to_datetime(df["ts"], errors="coerce"))
    df["placed_at"] = ts
    df["odds"]  = pd.to_numeric(df["odds"], errors="coerce")
    df["stake"] = pd.to_numeric(df["stake"], errors="coerce").fillna(0.0)
    df["p_win"] = pd.to_numeric(df["p_win"], errors="coerce")
    df["src"]   = source_tag
    return df

_MARKET_GROUPS = {
    "Moneyline":   ["ml","moneyline","money line","money-line"],
    "Spread":      ["spread","ats","handicap","point spread"],
    "Total (O/U)": ["total","totals","o/u","over/under","ou"],
    "Props":       ["prop","props","player","passing","rushing","receiving","td","interception","tackles","sacks"],
    "Parlay":      ["parlay"],
}
def classify_market(val: str) -> str:
    t = str(val or "").lower()
    for group, kws in _MARKET_GROUPS.items():
        if any(kw in t for kw in kws):
            return group
    if t == "total":
        return "Total (O/U)"
    return "Other"

def bankroll_curve(df: pd.DataFrame, bankroll_start: float = 100.0) -> pd.DataFrame:
    if df is None or df.empty:
        return pd.DataFrame(columns=["placed_at","bankroll","running_max","drawdown"])
    x = df.sort_values("placed_at").copy()
    x["pnl_realized"] = pd.to_numeric(x.get("pnl", 0), errors="coerce").fillna(0.0)
    x["cum_pnl"] = x["pnl_realized"].cumsum()
    x["bankroll"] = bankroll_start + x["cum_pnl"]
    x["running_max"] = x["bankroll"].cummax()
    x["drawdown"] = x["bankroll"] - x["running_max"]
    return x[["placed_at","bankroll","running_max","drawdown"]]

def summarize(df: pd.DataFrame, curve: pd.DataFrame) -> pd.DataFrame:
    if "result" not in df.columns:
        df = df.copy(); df["result"] = np.nan
    total_staked = float(pd.to_numeric(df.get("stake", pd.Series(dtype=float)), errors="coerce").fillna(0).sum())
    realized_mask = df.get("result", pd.Series(dtype=str)).astype(str).str.lower().isin(
        ["win","won","w","lose","lost","l","push","void","cancel","canceled","cancelled"]
    )
    realized = df[realized_mask].copy()
    wins   = realized["result"].astype(str).str.lower().isin(["win","won","w"]).sum()
    losses = realized["result"].astype(str).str.lower().isin(["lose","lost","l"]).sum()
    pushes = realized["result"].astype(str).str.lower().isin(["push","void","cancel","canceled","cancelled"]).sum()
    settled = len(realized)
    realized_pnl = float(pd.to_numeric(realized.get("pnl", 0), errors="coerce").fillna(0).sum())
    if realized_pnl == 0 and settled:
        total = 0.0
        for _, r in realized.iterrows():
            pnl, _ = settle_row(r if r.get("stake") not in (None, 0) else {"stake": r.get("stake_sim", 0.0), "odds": r.get("odds"), "result": r.get("result")})
            total += pnl
        realized_pnl = total
    roi      = (realized_pnl / total_staked) if total_staked else np.nan
    avg_odds = pd.to_numeric(realized.get("odds", pd.Series(dtype=float)), errors="coerce").mean()
    max_dd   = float(curve["drawdown"].min()) if not curve.empty else 0.0
    return pd.DataFrame([{
        "bets": len(df), "settled": int(settled), "wins": int(wins), "losses": int(losses), "pushes": int(pushes),
        "staked_units": round(total_staked, 2), "realized_pnl": round(realized_pnl, 2),
        "roi": round(roi, 4) if pd.notna(roi) else np.nan,
        "avg_odds": round(float(avg_odds), 2) if pd.notna(avg_odds) else np.nan,
        "max_drawdown": round(max_dd, 2),
    }])

def _infer_season_week(df: pd.DataFrame) -> pd.DataFrame:
    df = df.copy()
    ts = pd.to_datetime(df.get("placed_at").fillna(df.get("ts")), errors="coerce", utc=True)

    s = pd.to_numeric(df.get("season"), errors="coerce")
    df["season"] = s
    if ts is not None:
        df.loc[df["season"].isna(), "season"] = ts.dt.year
    df["season"] = df["season"].astype("Int64")

    w = pd.to_numeric(df.get("week"), errors="coerce")
    if w is None or (hasattr(w, "isna") and w.isna().all()):
        if ts is not None:
            w = ts.dt.isocalendar().week.astype("Int64")
    else:
        w = w.astype("Int64")
    df["week"] = w
    return df

def _preview_seasons_weeks() -> Tuple[List[str], Dict[str, List[int]]]:
    current = dt.datetime.utcnow().year
    seasons = [str(y) for y in range(1966, current + 1)]
    weeks_by_season: Dict[str, List[int]] = {s: list(range(1, 23)) for s in seasons}
    return seasons, weeks_by_season

def apply_policy(df: pd.DataFrame, policy: str, bankroll_start: float, unit_size: float, kelly_frac: float) -> pd.DataFrame:
    if df is None or df.empty:
        return pd.DataFrame(columns=["placed_at","odds","stake","stake_sim","p_win","policy","pnl","result"])
    df = df.copy()
    if "result" not in df.columns:
        df["result"] = np.nan
    df["policy"] = policy
    df["stake_sim"] = 0.0
    rows = []
    for _, r in df.sort_values("placed_at").iterrows():
        p_win = r.get("p_win")
        odds  = r.get("odds")
        if pd.isna(p_win) and pd.notna(odds):
            p_win = implied_prob_from_american(float(odds))
        elif pd.isna(p_win):
            p_win = 0.5
        if policy == "flat_units":
            stake = apply_staking_policy(row, bankroll_now, policy, unit_size, pct_bank=pct_bank if "pct_bank" in locals() else None, kelly_frac=kelly_frac if "kelly_frac" in locals() else None)
        elif policy == "percent_bankroll":
            stake = apply_staking_policy(row, bankroll_now, policy, unit_size, pct_bank=pct_bank if "pct_bank" in locals() else None, kelly_frac=kelly_frac if "kelly_frac" in locals() else None)
        else:
            stake = float(bankroll_start) * float(kelly_fraction(float(p_win), float(odds), fraction=kelly_frac))
        rows.append({**r.to_dict(), "p_win": p_win, "stake_sim": stake})
    out = pd.DataFrame(rows)
    if "result" not in out.columns:
        out["result"] = np.nan
    def _pnl(row):
        base = row if not pd.isna(row.get("stake")) and row.get("stake") not in (None, 0) else {
            "stake": row.get("stake_sim", 0.0), "odds": row.get("odds"), "result": row.get("result")
        }
        pnl, _ = settle_row(base)
        return pnl
    out["pnl"] = out.apply(_pnl, axis=1)
    return out

# ---------------- UI ----------------
st.set_page_config(page_title="Backtest", page_icon="ÃƒÆ’Ã‚Â°Ãƒâ€¦Ã‚Â¸ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒâ€¹Ã¢â‚¬Â ", layout="wide")
st.header("Backtest")

# --- Reactive filters OUTSIDE the form ---
c1, c2, c3 = st.columns([1,1,2])
sport = c1.text_input("Sport (default NFL)", value="NFL")
seasons, _weeks_map = _preview_seasons_weeks()
season_choice = c2.selectbox("Season", options=["All"] + seasons, index=0)

c4, c5 = st.columns([1,3])
market_sel = c4.multiselect(
    "Markets (choose one or more)",
    options=list(_MARKET_GROUPS.keys()),
    default=["Moneyline","Spread","Total (O/U)","Props","Parlay"],
)

week_opts = list(range(1, 23)) if season_choice != "All" else []
week_choice = c5.multiselect(
    "Weeks (if season selected)",
    options=week_opts,
    default=week_opts,
    key=f"weeks_{season_choice}" if season_choice != "All" else "weeks_all",
)
st.caption(f"DEBUG season={season_choice!s}, week_opts={len(week_opts)}")

# --- Run controls INSIDE the form ---
with st.form("backtest_form_v4"):
    c6, c7 = st.columns([1,1])
    min_edge = c6.number_input("Min edge (%)", min_value=0.0, value=0.0, step=0.25, key="min_edge")
    use_logs = c7.checkbox("Use bets_log.csv + parlays.csv", value=True, key="use_logs")

    c8, c9, c10 = st.columns(3)
    policy   = c8.selectbox("Staking policy", ["flat_units","percent_bankroll","kelly_frac"], index=0, key="policy")
    bankroll = c9.number_input($1150, value=100.0, step=1.0, key="bankroll")
    if policy == "flat_units":
        unit_size = c10.number_input($15, value=1.0, step=0.25, key="unit_size_flat")
        k_frac = 0.5
    elif policy == "percent_bankroll":
        unit_size = c10.number_input("Percent of bankroll (e.g., 0.01 = 1%)", min_value=0.0001, max_value=1.0, value=0.01, step=0.005, format="%.4f", key="unit_size_pct")
        k_frac = 0.5
    else:
        unit_size = 1.0
        k_frac = c10.number_input("Kelly fraction", min_value=0.01, max_value=1.0, value=0.5, step=0.05, key="kelly_frac")

    bl_test = _read_csv_safe(EXPORTS / "bets_log.csv")
    pl_test = _read_csv_safe(EXPORTS / "parlays.csv")
    eg_test = _read_csv_safe(EXPORTS / "edges.csv")
    rows_bl = 0 if bl_test is None or bl_test.empty else len(bl_test)
    rows_pl = 0 if pl_test is None or pl_test.empty else len(pl_test)
    rows_eg = 0 if eg_test is None or eg_test.empty else len(eg_test)
    st.caption(f"Data check bets_log.csv: {rows_bl} | parlays.csv: {rows_pl} | edges.csv: {rows_eg} | exports: {EXPORTS}")
    if rows_bl + rows_pl == 0 and rows_eg > 0 and use_logs:
        use_logs = False
        st.info("Logs are empty; using edges.csv instead.")

    submitted = st.form_submit_button("Run Backtest", key="submit_backtest_v4")

if submitted:
    try:
        # ---- Build base dataframe
        df_list: List[pd.DataFrame] = []
        if use_logs:
            bl = normalize_bets(_read_csv_safe(EXPORTS / "bets_log.csv"), "bets_log")
            pl = normalize_bets(_read_csv_safe(EXPORTS / "parlays.csv"), "parlays")
            df_list += [bl, pl]
        else:
            eg = _read_csv_safe(EXPORTS / "edges.csv")
            if not eg.empty:
                eg = eg.copy()
                eg.columns = [c.lower() for c in eg.columns]
                keep = ["ts","sport","league","game_id","market","ref","side","line","odds","p_win","result"]
                for c in keep:
                    if c not in eg.columns: eg[c] = None
                eg["placed_at"] = pd.to_datetime(eg["ts"], errors="coerce")
                eg["stake"] = 0.0
                df_list.append(eg[keep + ["placed_at","stake"]])

        parts = [d for d in df_list if d is not None and not d.empty]
        base = pd.concat(parts, ignore_index=True) if parts else pd.DataFrame()

        if base.empty:
            st.warning("No data after loading. Try Season=All and Min edge=0.")
        else:
            base.columns = [c.lower() for c in base.columns]
            for col in ("market","sport","league","season","week","result"):
                if col not in base.columns:
                    base[col] = None
            base["market_group"] = base["market"].map(classify_market) if "market" in base.columns else "Other"

            def show_count(label, df):
                st.caption(f"{label}: {len(df)} rows")

            show_count("loaded", base)

            # sport fallback & filter
            if "sport" in base.columns and base["sport"].isna().all() and "league" in base.columns:
                base["sport"] = base["league"]
            elif "sport" in base.columns and "league" in base.columns:
                base["sport"] = base["sport"].fillna(base["league"])

            if str(sport).strip() and "sport" in base.columns and base["sport"].notna().any():
                filtered = base[base["sport"].astype(str).str.contains(str(sport), case=False, na=False)]
                if len(filtered) > 0:
                    base = filtered
                else:
                    st.info(f"No rows match sport '{sport}'. Keeping all sports.")
            show_count("after sport filter", base)

                        # infer season/week (adds placed_at→year fallback)
            base = _infer_season_week(base)

            # season filter (never drop all)
            if season_choice != "All" and "season" in base.columns and base["season"].notna().any():
                filtered = base[base["season"].astype(str) == str(season_choice)]
                if len(filtered) > 0:
                    base = filtered
                else:
                    st.info(f"No rows match season {season_choice}. Keeping all seasons.")
            show_count("after season filter", base)

            # week filter (never drop all; tolerate NA weeks)
            if week_choice and "week" in base.columns:
                wk = pd.to_numeric(base["week"], errors="coerce").astype("Int64")
                week_ints = pd.array([int(w) for w in week_choice], dtype="Int64")
                mask = wk.isin(week_ints) | wk.isna()  # keep NAs so we don't nuke rows
                filtered = base[mask]
                if len(filtered) > 0:
                    base = filtered
                else:
                    st.info("No rows match selected weeks. Keeping all weeks.")
            show_count("after week filter", base)

            # market filter (never drop all)
            if market_sel and "market_group" in base.columns:
                filtered = base[base["market_group"].isin(market_sel)]
                if len(filtered) > 0:
                    base = filtered
                else:
                    st.info("No rows match selected markets. Keeping all markets.")
            show_count("after market filter", base)

            # EV filter (skip when threshold <= 0 or column missing)
            if "ev" in base.columns and float(min_edge) > 0:
                ev_pct = pd.to_numeric(base["ev"], errors="coerce") * 100.0
                mask = ev_pct >= float(min_edge)
                filtered = base[mask]
                if len(filtered) > 0:
                    base = filtered
                else:
                    st.info("No rows match Min edge. Keeping all (ignoring Min edge).")
            else:
                st.caption("EV filter skipped (no 'ev' column or Min edge <= 0).")
            show_count("after ev filter", base)



            # simulate / outputs
            if base.empty:
                st.warning("No rows to simulate. Try Season=All, Min edge=0, or uncheck logs to use edges.csv.")
            else:
                pol_df = apply_policy(base, policy=policy, bankroll_start=bankroll, unit_size=unit_size, kelly_frac=k_frac)
                if "result" not in pol_df.columns:
                    pol_df["result"] = np.nan

                curve  = bankroll_curve(pol_df, bankroll_start=bankroll)
                summary = summarize(pol_df, curve)

                st.subheader("Summary")
                st.dataframe(summary, use_container_width=True)# == CR_METRICS_CALL ==
try:
    _df_for_metrics = df_filtered.copy()
    # ensure columns exist
    for col in ["pnl","stake_sim"]:
        if col not in _df_for_metrics.columns:
            _df_for_metrics[col] = 0.0
    _metrics = compute_metrics(_df_for_metrics)
    render_metrics(_metrics)
except Exception as _e:
    st.caption(f"metrics error: {_e}")


                st.subheader("Bankroll curve (realized only)
                if not curve.empty:
                    st.line_chart(curve.set_index("placed_at")["bankroll"], use_container_width=True)
                else:
                    st.caption("No settled bets to plot.")

                st.subheader("Bets (filtered)")
                show_cols = [c for c in [
                    "placed_at","sport","league","game_id","season","week","market","market_group",
                    "ref","side","line","odds","p_win","ev","stake","stake_sim","result","pnl","policy","tag","src"
                ] if c in pol_df.columns]
                st.dataframe(pol_df[show_cols] if show_cols else pol_df, use_container_width=True)
    except Exception as e:
        st.error(f"Backtest page error: {e}")




# == CR_METRICS_HELPERS ==
import numpy as np
import pandas as pd
import math
import streamlit as st

def _max_drawdown(equity):
    peak = equity.cummax()
    dd = equity - peak
    max_dd = dd.min()
    in_dd = equity < peak
    longest = 0
    current = 0
    for v in in_dd:
        if v: current += 1
        else:
            longest = max(longest, current)
            current = 0
    longest = max(longest, current)
    return float(max_dd), int(longest)

def _brier(prob, result):
    m = (~prob.isna())
    if m.sum() == 0: return None
    return float(np.mean((prob[m] - result[m])**2))

def _logloss(prob, result, eps=1e-12):
    m = (~prob.isna())
    if m.sum() == 0: return None
    p = prob[m].clip(eps, 1-eps)
    y = result[m]
    ll = -(y*np.log(p) + (1-y)*np.log(1-p)).mean()
    return float(ll)

def compute_metrics(df):
    if df.empty: return {}
    bets = len(df)
    pushes = int((df["result"]=="push").sum()) if "result" in df else 0
    wins   = int((df["result"]=="win").sum())  if "result" in df else None
    losses = int((df["result"]=="lose").sum()) if "result" in df else None
    staked = float(df["stake_sim"].sum()) if "stake_sim" in df else 0.0
    pnl    = float(df["pnl"].sum())       if "pnl" in df else 0.0
    roi    = (pnl / staked) if staked else 0.0
    winrate = (wins / max(1,(wins or 0)+(losses or 0))) if wins is not None and losses is not None else None
    gross_win  = float(df.loc[df["pnl"]>0, "pnl"].sum()) if "pnl" in df else 0.0
    gross_loss = float(-df.loc[df["pnl"]<0, "pnl"].sum()) if "pnl" in df else 0.0
    profit_factor = (gross_win / gross_loss) if gross_loss>0 else None
    avg_odds = float(df["odds"].astype(float).mean()) if "odds" in df else None
    equity = (df["pnl"].cumsum())
    max_dd, dd_len = _max_drawdown(equity.fillna(0.0))
    y = df["result"].map({"win":1,"lose":0}) if "result" in df else pd.Series(index=df.index, dtype=float)
    brier = _brier(df.get("p_win", pd.Series(index=df.index, dtype=float)).astype(float), y.astype(float)) if "p_win" in df else None
    logloss = _logloss(df.get("p_win", pd.Series(index=df.index, dtype=float)).astype(float), y.astype(float)) if "p_win" in df else None
    by_market = None
    if "market" in df:
        by_market = (df.assign(win=(df["result"]=="win").astype(int),
                               loss=(df["result"]=="lose").astype(int))
          .groupby("market").agg(bets=("market","size"),
                                 wins=("win","sum"),
                                 losses=("loss","sum"),
                                 staked=("stake_sim","sum"),
                                 pnl=("pnl","sum"))
          .assign(roi=lambda x: x["pnl"]/x["staked"].replace(0,np.nan))
          .reset_index())
    return {
        "bets": bets, "wins": wins, "losses": losses, "pushes": pushes,
        "staked_units": staked, "realized_pnl": pnl, "roi": roi,
        "win_rate": winrate, "profit_factor": profit_factor,
        "avg_odds": avg_odds, "max_drawdown": max_dd, "dd_bars": dd_len,
        "brier": brier, "logloss": logloss, "by_market": by_market,
    }

def render_metrics(metrics):
    c1,c2,c3,c4,c5 = st.columns(5)
    with c1: st.metric("Bets", metrics.get("bets",0))
    with c2: st.metric("Win rate", f"{metrics['win_rate']*100:.1f}%" if metrics.get("win_rate") is not None else "—")
    with c3: st.metric("ROI", f"{metrics['roi']*100:.1f}%" if metrics.get("roi") is not None else "—")
    with c4: st.metric("Profit Factor", f"{metrics['profit_factor']:.2f}" if metrics.get("profit_factor") else "—")
    with c5: st.metric("Max DD (u)", f"{metrics['max_drawdown']:.2f}")
    c6,c7 = st.columns(2)
    with c6: st.metric("Brier", f"{metrics['brier']:.4f}" if metrics.get("brier") is not None else "—")
    with c7: st.metric("Log loss", f"{metrics['logloss']:.4f}" if metrics.get("logloss") is not None else "—")
    if isinstance(metrics.get("by_market"), pd.DataFrame) and not metrics["by_market"].empty:
        st.subheader("By market")
        st.dataframe(metrics["by_market"])
