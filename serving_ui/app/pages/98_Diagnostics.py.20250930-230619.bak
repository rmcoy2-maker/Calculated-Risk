from __future__ import annotations
# === AppImportGuard (nuclear) ===
try:
    from app.lib.auth import login, show_logout
except ModuleNotFoundError:
    import sys
    from pathlib import Path
    here = Path(__file__).resolve()

    base = None
    auth_path = None
    for p in [here] + list(here.parents):
        cand1 = p / "app" / "lib" / "auth.py"
        cand2 = p / "serving_ui" / "app" / "lib" / "auth.py"
        if cand1.exists():
            base, auth_path = p, cand1
            break
        if cand2.exists():
            base, auth_path = (p / "serving_ui"), cand2
            break

    if base and auth_path:
        s = str(base)
        if s not in sys.path:
            sys.path.insert(0, s)
        try:
            from app.lib.auth import login, show_logout  # type: ignore
        except ModuleNotFoundError:
            import types, importlib.util
            if "app" not in sys.modules:
                pkg_app = types.ModuleType("app")
                pkg_app.__path__ = [str(Path(base) / "app")]
                sys.modules["app"] = pkg_app
            if "app.lib" not in sys.modules:
                pkg_lib = types.ModuleType("app.lib")
                pkg_lib.__path__ = [str(Path(base) / "app" / "lib")]
                sys.modules["app.lib"] = pkg_lib
            spec = importlib.util.spec_from_file_location("app.lib.auth", str(auth_path))
            mod = importlib.util.module_from_spec(spec)  # type: ignore[arg-type]
            assert spec and spec.loader
            spec.loader.exec_module(mod)  # type: ignore[attr-defined]
            sys.modules["app.lib.auth"] = mod
            login = mod.login
            show_logout = mod.show_logout
    else:
        raise
# === /AppImportGuard ===


import sys
from pathlib import Path
import streamlit as st
_here = Path(__file__).resolve()
for up in [_here] + list(_here.parents):
    cand = up / 'serving_ui' / 'app' / '__init__.py'
    if cand.exists():
        base = str((up / 'serving_ui').resolve())
        if base not in sys.path:
            sys.path.insert(0, base)
        break
PAGE_PROTECTED = False
auth = login(required=PAGE_PROTECTED)
if not auth.ok:
    st.stop()
show_logout()
auth = login(required=False)
if not auth.authenticated:
    st.info('You are in read-only mode.')
show_logout()
import sys
from pathlib import Path
_HERE = Path(__file__).resolve()
_SERVING_UI = _HERE.parents[2]
if str(_SERVING_UI) not in sys.path:
    sys.path.insert(0, str(_SERVING_UI))
st.set_page_config(page_title='98 Diagnostics', page_icon='ðŸ“ˆ', layout='wide')
try:
    from app.utils.diagnostics import mount_in_sidebar
except ModuleNotFoundError:
    try:
        import sys
        from pathlib import Path as _efP
        sys.path.append(str(_efP(__file__).resolve().parents[3]))
        from app.utils.diagnostics import mount_in_sidebar
    except Exception:
        try:
            from utils.diagnostics import mount_in_sidebar
        except Exception:

            def mount_in_sidebar(page_name: str):
                return None
import json
from collections import defaultdict, deque
from datetime import datetime
from pathlib import Path
import pandas as pd
st.title('ðŸ©º Edge Finder â€” Unified Diagnostics')
REPO_ROOT = Path(__file__).resolve().parents[2]
EXPORTS = REPO_ROOT / 'exports'
LOG_DIR = EXPORTS / 'diag_logs'
LOG_DIR.mkdir(parents=True, exist_ok=True)

def load_logs() -> pd.DataFrame:
    rows = []
    for p in sorted(LOG_DIR.glob('diag-*.jsonl'))[-7:]:
        try:
            with p.open('r', encoding='utf-8') as f:
                for line in f:
                    try:
                        j = json.loads(line)
                        rows.append(j)
                    except Exception:
                        pass
        except Exception:
            pass
    return pd.DataFrame(rows) if rows else pd.DataFrame(columns=['ts', 'page', 'kind', 'level', 'msg'])
logs = load_logs()
st.caption(f'Loaded {len(logs):,} log events from {LOG_DIR}')
st.subheader('Page Status')
if logs.empty:
    st.info('No diagnostics events recorded yet. Visit any data-handling page to generate logs.')
else:

    def _parse_ts(x):
        try:
            return datetime.fromisoformat(str(x))
        except Exception:
            return None
    logs['_dt'] = logs['ts'].map(_parse_ts)
    g = logs.groupby('page', dropna=True)
    summary = pd.DataFrame({'last_event_ts': g['_dt'].max(), 'events': g['page'].count(), 'warnings': g.apply(lambda df: int((df['level'] == 'warning').sum())), 'errors': g.apply(lambda df: int((df['level'] == 'error').sum()))}).reset_index().sort_values(['errors', 'warnings', 'last_event_ts'], ascending=[False, False, False])
    st.dataframe(summary, hide_index=True, width='stretch')
    st.subheader('Recent Events')
    pages = ['(all)'] + sorted(summary['page'].tolist())
    pick = st.selectbox('Filter by page', pages, index=0)
    view = logs if pick == '(all)' else logs[logs['page'] == pick]
    view = view.sort_values('_dt', ascending=False).head(500)[['ts', 'page', 'level', 'kind', 'msg']]
    st.dataframe(view, hide_index=True, width='stretch')
st.divider()
st.subheader('Exports Health')
files = {'bets_log.csv': EXPORTS / 'bets_log.csv', 'parlays.csv': EXPORTS / 'parlays.csv', 'edges.csv': EXPORTS / 'edges.csv', 'scores_1966-2025.csv': EXPORTS / 'scores_1966-2025.csv', 'settled.csv': EXPORTS / 'settled.csv'}
rows = []
for label, p in files.items():
    exists = p.exists()
    size = p.stat().st_size if exists else 0
    row = {'file': label, 'exists': exists, 'size': size}
    if exists and size > 0:
        try:
            df = pd.read_csv(p, nrows=5)
            row['preview_rows'] = len(df)
            row['preview_cols'] = len(df.columns)
        except Exception as e:
            row['read_error'] = str(e)
    rows.append(row)
st.dataframe(pd.DataFrame(rows), hide_index=True, width='stretch')





