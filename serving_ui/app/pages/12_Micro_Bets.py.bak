from __future__ import annotations

# --- import bootstrap so 'app' package is importable when run from anywhere ---
import sys
from pathlib import Path
_HERE = Path(__file__).resolve()
_SERVING_UI = _HERE.parents[2]
if str(_SERVING_UI) not in sys.path:
    sys.path.insert(0, str(_SERVING_UI))
from app.lib.access import live_enabled

if live_enabled():
    # do live fetch / recompute / write / API calls
    do_expensive_refresh()
else:
    # skip; rely on cached CSVs in /exports that your app already loads
    pass

# -----------------------------------------------------------------------------

import math
import pandas as pd
import numpy as np
import streamlit as st

# Optional diagnostics
try:
    from app.utils.diagnostics import mount_in_sidebar
except Exception:
    def mount_in_sidebar(_: str | None = None): return None

st.set_page_config(page_title="Micro Bets â€” Locks & Moonshots", page_icon="ðŸŒ™", layout="wide")
mount_in_sidebar("12_Micro_Bets")

# =============== Helpers ===============
def _exports_dir() -> Path:
    # find repo root by walking up to `edge-finder`; else use nearest exports
    here = _HERE
    for up in [here] + list(here.parents):
        if up.name.lower() == "edge-finder":
            p = up / "exports"
            p.mkdir(parents=True, exist_ok=True)
            return p
    p = here.parents[2] / "exports"
    p.mkdir(parents=True, exist_ok=True)
    return p

def _load_edges() -> pd.DataFrame:
    exp = _exports_dir()
    for name in ["edges_graded_full_normalized_std.csv",
                 "edges_graded_full_normalized.csv",
                 "edges_graded_full.csv",
                 "edges.csv"]:
        f = exp / name
        if f.exists():
            try:
                df = pd.read_csv(f)
                df["_source_file"] = str(f)
                return df
            except Exception:
                pass
    return pd.DataFrame()

def _american_to_decimal(odds: float | int) -> float:
    try:
        o = float(odds)
    except Exception:
        return np.nan
    if o >= 100:
        return 1 + o / 100
    if o <= -100:
        return 1 + 100 / abs(o)
    return np.nan

def _to_decimal(series: pd.Series) -> pd.Series:
    s = pd.to_numeric(series, errors="coerce")
    if s.notna().any():
        # detect if already decimal (>1.01) or american (<=-100 or >=+100)
        guess_is_decimal = (s >= 1.01) & (s <= 1000)
        out = pd.Series(np.where(guess_is_decimal, s, np.nan), index=series.index, dtype="float64")
        need = out.isna()
        if need.any():
            out[need] = s[need].map(_american_to_decimal)
        return out
    return pd.to_numeric(series, errors="coerce")

def _implied_prob_from_decimal(d: pd.Series) -> pd.Series:
    d = pd.to_numeric(d, errors="coerce")
    return np.where(d>0, 1.0/d, np.nan)

def _ev_per_dollar(p: pd.Series, d: pd.Series) -> pd.Series:
    # EV per $1 stake using decimal odds
    p = pd.to_numeric(p, errors="coerce")
    d = pd.to_numeric(d, errors="coerce")
    return p * (d - 1) - (1 - p)

def _parlay_decimal(ds: list[float]) -> float:
    x = 1.0
    for v in ds:
        x *= float(v)
    return x

def _parlay_prob(ps: list[float]) -> float:
    x = 1.0
    for v in ps:
        x *= float(v)
    return x

# =============== UI ===============
st.title("Micro Bets â€” Locks & Moonshots")
st.caption("Locks: singles with a win-threshold and positive EV. Moonshots: parlays meeting your min odds & with positive EV.")

edges = _load_edges()
st.button("ðŸ”„ Refresh data", on_click=lambda: st.rerun())

colL, colR = st.columns(2)
with colL:
    lock_min_ev = st.number_input("Locks min EV per $1", value=0.02, step=0.01, format="%.2f")
with colR:
    moon_min_odds = st.number_input("Moonshots: min decimal odds", value=6.0, step=0.5, format="%.2f")
    moon_legs     = st.number_input("Moonshots: legs", value=3, min_value=2, max_value=10, step=1)

st.markdown("### Locks")
if edges.empty:
    st.info("No locks yet. Load edges CSVs in your `exports/` folder.")
else:
    work = edges.copy()
    # Normalize key fields (best-effort)
    if "odds" in work.columns:
        work["decimal"] = _to_decimal(work["odds"])
    elif "decimal" not in work.columns:
        work["decimal"] = np.nan
    # pick probability-like column
    pcols = [c for c in work.columns if str(c).lower() in ("p", "p_win", "prob", "prob_win", "implied_prob")]
    if pcols:
        p = pd.to_numeric(work[pcols[0]], errors="coerce")
    else:
        # fallback from decimal odds (house prob)
        p = pd.Series(_implied_prob_from_decimal(work["decimal"]), index=work.index)
    work["p_win"] = p
    work["_ev_per_$1"] = _ev_per_dollar(work["p_win"], work["decimal"])
    locks = work.loc[(work["_ev_per_$1"] >= float(lock_min_ev)) & work["p_win"].notna() & work["decimal"].notna()]

    st.dataframe(
        locks[
            [c for c in
             ["_date_iso","home","away","market","side","line","book","decimal","p_win","_ev_per_$1"]
             if c in locks.columns]
        ].sort_values("_ev_per_$1", ascending=False),
        use_container_width=True, hide_index=True
    )

st.markdown("### Moonshots")
st.caption("This is a simple helper: it groups by game & market, then picks the top EV legs and forms sample parlays.")
if edges.empty:
    st.info("No data to build moonshots.")
else:
    w = edges.copy()
    # normalize as above
    if "decimal" not in w.columns:
        w["decimal"] = _to_decimal(w.get("odds", np.nan))
    w["p_win"] = pd.to_numeric(w.get("p_win", w.get("prob", w.get("implied_prob", np.nan))), errors="coerce")
    w["_ev_per_$1"] = _ev_per_dollar(w["p_win"], w["decimal"])

    # candidate pool: EV-positive rows with valid prob and odds
    pool = w[(w["_ev_per_$1"] > 0) & w["p_win"].notna() & w["decimal"].notna()].copy()
    if pool.empty:
        st.info("No positive-EV legs found.")
    else:
        # one per (game_id, market) best EV
        keys = [c for c in ["game_id","market"] if c in pool.columns]
        if keys:
            pool = pool.sort_values("_ev_per_$1", ascending=False).drop_duplicates(subset=keys, keep="first")

        # build simple sample combos (first N legs)
        sample = pool.sort_values("_ev_per_$1", ascending=False).head(int(moon_legs))
        if len(sample) < int(moon_legs):
            st.warning(f"Only found {len(sample)} legs â‰¥0 EV. Showing a partial sample.")
        parl_odds = _parlay_decimal(sample["decimal"].tolist())
        parl_prob = _parlay_prob(sample["p_win"].tolist())
        ev_per1   = parl_prob * (parl_odds - 1) - (1 - parl_prob)

        st.write("**Sample parlay** (top EV legs):")
        st.dataframe(
            sample[[c for c in ["home","away","market","side","line","book","decimal","p_win","_ev_per_$1"] if c in sample.columns]],
            use_container_width=True, hide_index=True
        )
        st.metric("Parlay decimal odds", f"{parl_odds:,.2f}")
        st.metric("Parlay win prob (model)", f"{parl_prob:.2%}")
        st.metric("EV per $1", f"{ev_per1:+.3f}")
        if parl_odds >= float(moon_min_odds) and ev_per1 > 0:
            st.success("âœ… Meets moonshot thresholds.")
        else:
            st.info("Does not meet moonshot thresholds yet.")

